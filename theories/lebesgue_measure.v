(* -*- company-coq-local-symbols: (("`&`" . ?∩) ("`|`" . ?∪) ("set0" . ?∅)); -*- *)
(* mathcomp analysis (c) 2017 Inria and AIST. License: CeCILL-C.              *)
From mathcomp Require Import all_ssreflect ssralg ssrnum ssrint interval.
From mathcomp Require Import finmap.
Require Import boolp reals ereal classical_sets posnum nngnum topology.
Require Import mathcomp_extra functions normedtype.
From HB Require Import structures.
Require Import sequences measure csum cardinality.

(******************************************************************************)
(*                         Lebesgue Measure (WIP)                             *)
(*                                                                            *)
(* This file contains a formalization of the Lebesgue measure using the       *)
(* Caratheodory's theorem available in measure.v and develops the theory of   *)
(* measurable functions.                                                      *)
(*                                                                            *)
(* Reference:                                                                 *)
(* - Daniel Li, Intégration et applications, 2016                             *)
(*                                                                            *)
(*           setI_closed G == the set of sets G is closed under finite        *)
(*                            intersection                                    *)
(*           setU_closed G == the set of sets G is closed under finite union  *)
(*           setC_closed G == the set of sets G is closed under complement    *)
(*           setD_closed G == the set of sets G is closed under difference    *)
(*          ndseq_closed G == the set of sets G is closed under               *)
(*                            non-decreasing countable union                  *)
(*       trivIset_closed G == the set of sets G is closed under               *)
(*                            pairwise-disjoint countable union               *)
(* are_measurable_sets D G == the set of sets G forms a sigma algebra on D    *)
(*         gen_class T G P == class generated from G satisfying P, i.e.,      *)
(*                            \bigcap_(A in [set M | P M /\ G `<=` M]) A      *)
(*             s<| D, G |> == sigma-algebra generated by G on D               *)
(*                s<< G >> := s<| setT, G |>                                  *)
(*      g_measurableType G == the measurableType corresponding to s<< G >>    *)
(*    preimage_class D f G == class generated by the preimages of G by f      *)
(*       image_class D f G == class generated by the images of G by f         *)
(*   is_monotone_class D C == C is a monotone class of subsets of D           *)
(*                dynkin G == G is a set of sets that form a Dynkin (or a     *)
(*                            lambda) system                                  *)
(*                d<< G >> == Dynkin system generated by G, i.e.,             *)
(*                            gen_class G dynkin                              *)
(*             Hahn_ext mu == extension of the measure mu over a ring of sets *)
(*                            to a measure of the generated sigma algebra     *)
(*                                                                            *)
(*                miditv i == middle point of interval i                      *)
(*                 neitv i == the interval i is non-empty                     *)
(*                            when the support type is a numFieldType, this   *)
(*                            is equivalent to (i.1 < i.2)%O (lemma neitvE)   *)
(*                                                                            *)
(*             [sset of s] == the finite union of the list of intervals s     *)
(*                            (a "simple set")                                *)
(*                                                                            *)
(*              itv_cplt s == complement of the list of intervals s           *)
(*            itv_diff i j == i \ j where i and j are intervals assuming      *)
(*                            ~ j <= i                                        *)
(*        disjoint_itv i j == intervals i and j are disjoint                  *)
(*      contiguous_itv i j == intervals i and j are contiguous                *)
(*              lt_itv i j == total ordering of intervals: the left bound of  *)
(*                            i is smaller than the one of j, and if it is    *)
(*                            equal then the right bound of i is smaller than *)
(*                            the one of j                                    *)
(*              le_itv i j := (i = j) \/ lt_itv i j                           *)
(*                 ccitv n == the centered closed interval [-n, n]            *)
(*                                                                            *)
(*      sorted_decompose s == turns a *sorted* list of intervals s into a     *)
(*                            list of non-overlapping intervals with the same *)
(*                            cover                                           *)
(*             decompose s == turn a list of intervals into a sequence of     *)
(*                            non-overlapping intervals with the same cover   *)
(*                                                                            *)
(*             Module Sset == simple sets form an algebra of sets             *)
(*                                                                            *)
(*               hlength A == length of the hull of the set of real numbers A *)
(*             hlengthUitv == (lemma) hlength is additive on intervals        *)
(*                                                                            *)
(*               slength A == measure of the set A when it is a simple set,   *)
(*                            and 0 o.w.                                      *)
(*    slength_sigma_finite == (lemma) slength is sigma-finite                 *)
(*                                                                            *)
(*        nth_interval f k == kth interval in the sequence f of lists of      *)
(*                            intervals                                       *)
(*                                                                            *)
(* The main proof is the proof that slength is sigma-additive. We list up the *)
(* several lemmas that make up this:                                          *)
(*   slength_additive == slength is additive                                  *)
(*   slength_sigma_subadditive_finite_itv == slength is sigma-subadditive     *)
(*     on finite intervals                                                    *)
(*   slength_sigma_additive_finite_itv == slength is additive on finite       *)
(*     intervals                                                              *)
(*   slength_sigma_subadditive_infinite_itv == slength is sigma-subadditive   *)
(*     on infinite intervals                                                  *)
(*   slength_sigma_subadditive_itv == slength is sigma-subadditive on         *)
(*     intervals                                                              *)
(*   slength_sigma_additive_itv == slength is sigma-additive on intervals     *)
(*   slength_semi_sigma_additive == slength is sigma-additive on simple sets  *)
(*                                                                            *)
(*      lebesgue_measure == the Lebesgue measure                              *)
(*                                                                            *)
(*              ps_infty == inductive definition of the powerset              *)
(*                          {0, {-oo}, {+oo}, {-oo,+oo}}                      *)
(*         emeasurable G == sigma-algebra over \bar R built out the           *)
(*                          measurables G of a sigma-algebra over R           *)
(*     elebesgue_measure == the Lebesgue measure extended to \bar R           *)
(*                                                                            *)
(* The modules RGenOInfty, RGenInftyO, RGenCInfty, RGenOpens provide proofs   *)
(* of equivalence between the sigma-algebra generated by list of intervals    *)
(* and the sigma-algebras generated by open rays, closed rays, and open       *)
(* intervals.                                                                 *)
(* The modules ErealGenOInfty and ErealGenCInfty provide proofs of            *)
(* equivalence between emeasurable and the sigmaa-algebras generated open     *)
(* rays and closed rays.                                                      *)
(*                                                                            *)
(*             sdrop u n := {u_k | k >= n}                                    *)
(*                sups u := [sequence sup (sdrop u n)]_n                      *)
(*                infs u := [sequence inf (sdrop u n)]_n                      *)
(*         lim_{inf,sup} == limit inferior/superior for realType              *)
(*               esups u := [sequence ereal_sup (sdrop u n)]_n                *)
(*               einfs u := [sequence ereal_inf (sdrop u n)]_n                *)
(*        elim_{inf,sup} == limit inferior/superior for \bar R                *)
(*                                                                            *)
(* Several properties of measurable functions                                 *)
(*                                                                            *)
(*   prod_measurableType == product of measurableType                         *)
(*                                                                            *)
(*                                                                            *)
(******************************************************************************)

Set Implicit Arguments.
Unset Strict Implicit.
Unset Printing Implicit Defensive.
Import Order.TTheory GRing.Theory Num.Def Num.Theory.
Import numFieldTopology.Exports.

Local Open Scope classical_set_scope.
Local Open Scope ring_scope.
Local Open Scope ereal_scope.


(* NB: how useful? *)

(******************************************************************************)
(*                        /lemmas waiting to be PRed                          *)
(******************************************************************************)
(* mu_ext mu and mu coincide on measurable sets *)
Lemma measurable_mu_extE (R : realType) (T : semiRingOfSetsType)
    (mu : {additive_measure set T -> \bar R}) X :
  sigma_sub_additive mu ->
  measurable X -> [outer_measure of mu_ext mu] X = mu X.
Proof.
move=> muS mX; apply/eqP; rewrite eq_le; apply/andP; split.
  apply ereal_inf_lb; exists (fun n => if n is 0%N then X else set0).
    by split=> [[]// _|t Xt]; exists 0%N.
  apply/cvg_lim => //; rewrite -cvg_shiftS.
  rewrite (_ : [sequence _]_n = cst (mu X)); first exact: cvg_cst.
  by rewrite funeqE => n /=; rewrite big_nat_recl//= big1 ?adde0.
apply/lb_ereal_inf => x [A [mA XA] <-{x}].
have XUA : X = \bigcup_n (X `&` A n).
  rewrite predeqE => t; split => [Xt|[i _ []//]].
  by have [i _ Ait] := XA _ Xt; exists i; split.
apply: (@le_trans _ _ (\sum_(i <oo) mu (X `&` A i))).
  by rewrite muS//= -?XUA => // i; apply: measurableI.
apply lee_lim.
- by apply: is_cvg_ereal_nneg_series => n _; exact/measure_ge0.
- by apply: is_cvg_ereal_nneg_series => n _; exact/measure_ge0.
- near=> n; apply: lee_sum => i  _. apply: le_measure => //; rewrite ?inE//=.
  exact: measurableI.
Unshelve. all: by end_near. Qed.

Section Rmu_ext.
Import SetRing.

Lemma Rmu_ext (R : realType) (T : semiRingOfSetsType) (rT := @SetRing.ring T)
    (mu : {additive_measure set T -> \bar R}) :
  mu_ext [additive_measure of measure mu] = mu_ext mu.
Proof.
apply/funeqP => /= X; rewrite /mu_ext/=; apply/eqP; rewrite eq_le.
rewrite ?lb_ereal_inf// => _ [F [Fm XS] <-]; rewrite ereal_inf_lb//; last first.
  exists F; first by split=> // i; exact: measurableW.
  by rewrite (eq_ereal_pseries (fun=> RmuE _ _)).
pose K := [set: nat] `*`` fun i => [set` decomp (F i)].
have /ppcard_eqP[f] : (K #= [set: nat])%card.
  apply: cardMR_eq_nat => // i.
  by split=> //; apply/set0P; rewrite set_fset_eq0 decompN0.
pose g i := (f^-1%FUN i).2.
exists g; first split.
- move=> k; have [/= _] : K (f^-1%FUN k) by apply: funS.
  by apply: decomp_measurable.
- move=> i /XS [k _]; rewrite -[F k]cover_decomp => -[D /= DFk Di].
  by exists (f (k, D)) => //; rewrite /g invK// inE.
rewrite !ereal_pseries_csum//= /measure ?set_true.
rewrite -[RHS](eq_csum (fun _ _ => csum_fset _))// csum_csum//=.
rewrite (reindex_csum K setT f) => //=; apply: eq_csum => i Ki.
by rewrite /g funK ?inE.
Qed.

End Rmu_ext.

Lemma measurable_Rmu_extE (R : realType) (T : semiRingOfSetsType) (rT := @SetRing.ring T)
    (mu : {additive_measure set T -> \bar R}) X :
  sigma_sub_additive mu ->
  measurable (X : set rT)  -> [outer_measure of mu_ext mu] X = SetRing.measure mu X.
Proof.
move=> mu_sub Xm/=; rewrite -Rmu_ext/= measurable_mu_extE//.
exact: ring_sigma_sub_additive.
Qed.

(* Coercion measure_additive_measure : Measure.map >-> AdditiveMeasure.map. *)

Section measure_unique.
Variables (R : realType) (T : measurableType) (G : set (set T)).
Variable g : (set T)^nat.
Hypotheses (mG : measurable = s<< G >>) (setIG : setI_closed G).
Hypotheses (Gg : forall i, G (g i)).
Hypothesis g_cover : \bigcup_k (g k) = setT.
Variables m1 m2 : {measure set T -> \bar R}.
Hypothesis m1m2 : forall A, G A -> m1 A = m2 A.
Hypothesis m1goo : forall k, (m1 (g k) < +oo)%E.

Lemma measure_unique : forall E, measurable E -> m1 E = m2 E.
Proof.
move=> E mA; apply: (@g_salgebra_measure_unique _ _ G); rewrite -?mG//.
by rewrite mG; exact: g_salgebra_self.
Qed.

End measure_unique.
Arguments measure_unique {R T} G g.

Section Hahn_extension.
Variables (R : realType) (T : semiRingOfSetsType) (mu : {additive_measure set T -> \bar R}).
Variable mu_sub : sigma_sub_additive mu.
Local Notation rT := (@SetRing.ring T).
Let Rmu := SetRing.measure mu.
Let mstar : {outer_measure set T -> \bar R} := [outer_measure of mu_ext mu].
Let Rmstar : {outer_measure set rT -> \bar R} :=
   [outer_measure of mu_ext [additive_measure of Rmu]].
Let M : measurableType := [the measurableType of caratheodory_type mstar].
Let muR_sub := ring_sigma_sub_additive mu_sub.

Lemma subset_g_salgebra_caratheodory : s<< @measurable T >> `<=` @measurable M.
Proof.
suff: s<< @measurable rT >> `<=` @measurable M.
   by apply: subset_trans; apply: subset_g_salgebra => x /SetRing.measurableW.
apply: g_salgebra_smallest; last first.
  split => //; [by move=> X mX; rewrite setTD; exact: measurableC |
    by move=> u_ mu_; exact: measurable_bigcup].
move=> A mA; apply le_caratheodory_measurable => // X.
apply lb_ereal_inf => _ [B [mB XB] <-].
rewrite -(eq_ereal_pseries (fun=> SetRing.RmuE _ _))=> //.
have RmB i : measurable (B i : set rT) by exact: SetRing.measurableW.
set BA := eseries (fun n => Rmu (B n `&` A)).
set BNA := eseries (fun n => Rmu (B n `&` ~` A)).
apply (@le_trans _ _ (lim BA + lim BNA)); [apply: lee_add|].
  - rewrite (_ : BA = eseries (fun n => mstar (B n `&` A))); last first.
      rewrite funeqE => n; apply: eq_bigr => i _.
      by rewrite /Rmstar /= measurable_Rmu_extE //; exact: measurableI.
    apply (@le_trans _ _ (mstar (\bigcup_k (B k `&` A)))).
      by apply le_mu_ext; rewrite -setI_bigcupl; apply setISS.
    exact: outer_measure_sigma_subadditive.
  - rewrite (_ : BNA = eseries (fun n => mstar (B n `\` A))); last first.
      rewrite funeqE => n; apply eq_bigr => i _.
      rewrite /Rmstar /= measurable_Rmu_extE //; exact: measurableD.
    apply (@le_trans _ _ (mstar (\bigcup_k (B k `\` A)))).
      by apply le_mu_ext; rewrite -setI_bigcupl; apply setISS.
    exact: outer_measure_sigma_subadditive.
have ? : cvg BNA.
  apply/is_cvg_ereal_nneg_series => n _.
  by rewrite -setDE; apply: measure_ge0 => //; apply: measurableD.
have ? : cvg BA.
  apply/is_cvg_ereal_nneg_series => n _.
  by apply: measure_ge0 => //; apply: measurableI.
have ? : cvg (eseries (Rmu \o B)).
  by apply/is_cvg_ereal_nneg_series => n _; exact: measure_ge0.
have [def|] := boolP (adde_def (lim BA) (lim BNA)); last first.
  rewrite /adde_def negb_and !negbK=> /orP[/andP[BAoo BNAoo]|/andP[BAoo BNAoo]].
  - suff -> : lim (eseries (Rmu \o B)) = +oo by rewrite lee_pinfty.
    apply/eqP; rewrite -lee_pinfty_eq -(eqP BAoo); apply/lee_lim => //.
    near=> n; apply: lee_sum => m _; apply: le_measure; rewrite /mkset; by
      [rewrite inE; exact: measurableI | rewrite inE | apply: subIset; left].
  - suff -> : lim (eseries (Rmu \o B)) = +oo by rewrite lee_pinfty.
    apply/eqP; rewrite -lee_pinfty_eq -(eqP BNAoo); apply/lee_lim => //.
    near=> n; apply: lee_sum => m _; rewrite -setDE; apply: le_measure;
      rewrite /mkset; by [rewrite inE; exact: measurableD |
                          rewrite inE | apply: subIset; left].
rewrite -ereal_limD // (_ : (fun _ => _) =
    eseries (fun i => Rmu (B i `&` A) + Rmu (B i `&` ~` A))); last first.
  by rewrite funeqE => n; rewrite -big_split /=; apply eq_bigr.
apply/lee_lim => //.
  apply/is_cvg_ereal_nneg_series => // n _; apply/adde_ge0.
  by apply: measure_ge0 => //; apply: measurableI.
  by rewrite -setDE; apply: measure_ge0; apply: measurableD.
near=> n; apply: lee_sum => i _; rewrite -measure_semi_additive2.
- apply: le_measure; rewrite /mkset; [|
    by rewrite inE | by rewrite -setIUr setUCr setIT].
  rewrite inE.
  by apply: measurableU; [exact: measurableI |
                          rewrite -setDE; exact: measurableD].
- exact: measurableI.
- by rewrite -setDE; exact: measurableD.
- apply: measurableU; [exact: measurableI | rewrite -setDE; exact: measurableD].
- by rewrite setIACA setICr setI0.
Unshelve. all: by end_near. Qed.

Let I : measurableType := g_measurableType (@measurable T).

Definition Hahn_ext : set I -> \bar R := mu_ext mu.

Local Lemma Hahn_ext0 : Hahn_ext set0 = 0.
Proof. exact: mu_ext0. Qed.

Local Lemma Hahn_ext_ge0 (A : set I) : 0 <= Hahn_ext A.
Proof. exact: mu_ext_ge0. Qed.

Local Lemma Hahn_ext_sigma_additive : semi_sigma_additive Hahn_ext.
Proof.
move=> F mF tF mUF; rewrite /Hahn_ext.
apply: (@caratheodory_measure_sigma_additive _ _ mstar) => //; last first.
  exact: subset_g_salgebra_caratheodory.
by move=> i; exact: (subset_g_salgebra_caratheodory (mF i)).
Qed.

Canonical Hahn_ext_measure : {measure set I -> \bar R} :=
  @Measure.Pack _ _ _ Hahn_ext (Measure.Axioms
    Hahn_ext0 Hahn_ext_ge0 Hahn_ext_sigma_additive).

Lemma Hahn_ext_sigma_finite : @sigma_finite _ T setT mu ->
  @sigma_finite _ I setT Hahn_ext.
Proof.
move=> -[S setTS mS]; exists S => //; move=> i; split.
  by have := (mS i).1; exact: g_salgebra_self.
by rewrite /Hahn_ext /= measurable_mu_extE //;
  [exact: (mS i).2 | exact: (mS i).1].
Qed.

Lemma Hahn_ext_unique : @sigma_finite _ T setT mu ->
  (forall mu' : {measure set I -> \bar R},
    (forall X, @measurable T X -> mu X = mu' X) ->
    (forall X, @measurable I X -> Hahn_ext X = mu' X)).
Proof.
move=> [F TF /all_and2[Fm muF]] mu' mu'mu X mX.
apply: (@measure_unique _ I (@measurable T) F) => //=.
- by move=> A B Am Bm; apply: measurableI.
- by move=> A Am; rewrite /Hahn_ext/= measurable_mu_extE// mu'mu.
- by move=> k; rewrite /Hahn_ext/= measurable_mu_extE.
Qed.
End Hahn_extension.

Lemma caratheodory_measurable_mu_ext (R : realType) (T : measurableType)
    (mu : {measure set T -> \bar R}) A :
  let mu' := [additive_measure of mu] in
  measurable A -> [outer_measure of mu_ext mu'].-measurable A.
Proof.
move=> mu' Am; apply: subset_g_salgebra_caratheodory => //.
  exact: measure_sigma_sub_additive.
exact: g_salgebra_self.
Qed.

Local Close Scope ereal_scope.

Section lte_bnd.
Variables (d : unit) (T : porderType d).
Implicit Types (x y : T) (b : bool).

Local Lemma BLeft_ltE x y : (BLeft x < BLeft y)%O = (x < y)%O.
Proof. by []. Qed.
Local Lemma BRight_leE x y : (BRight x <= BRight y)%O = (x <= y)%O.
Proof. by []. Qed.
Local Lemma BRight_BLeft_leE x y : (BRight x <= BLeft y)%O = (x < y)%O.
Proof. by []. Qed.
Local Lemma BLeft_BRight_ltE x y : (BLeft x < BRight y)%O = (x <= y)%O.
Proof. by []. Qed.
Local Lemma BRight_BSide_ltE x y b : (BRight x < BSide b y)%O = (x < y)%O.
Proof. by case: b. Qed.
Local Lemma BLeft_BSide_leE x y b : (BLeft x <= BSide b y)%O = (x <= y)%O.
Proof. by case: b. Qed.

Definition lte_bnd := (BLeft_ltE, BLeft_BRight_ltE, BRight_BSide_ltE,
  BLeft_BSide_leE, BRight_BLeft_leE, BRight_leE).

Lemma BSide_BRight_leE x y b : (BSide b x <= BRight y)%O = (x <= y)%O.
Proof. by case: b. Qed.
Lemma BSide_BLeft_leE x y b : (BSide b x < BLeft y)%O = (x < y)%O.
Proof. by case: b. Qed.
Lemma BSide_leE x y b : (BSide b x <= BSide b y)%O = (x <= y)%O.
Proof. by case: b. Qed.
Lemma BSide_ltE x y b : (BSide b x < BSide b y)%O = (x < y)%O.
Proof. by case: b. Qed.

End lte_bnd.

Lemma ltBRight_leBLeft (d : unit) (T : porderType d) (a : itv_bound T) (r : T) :
  (a < BRight r)%O -> (a <= BLeft r)%O.
Proof. by move: a => [[] a|[]]. Qed.

Lemma itv_meet_mem (d : unit) (T : orderType d) (i1 i2 j1 j2 : itv_bound T)
    (x : T) :
  x \in itv_meet (Interval i1 i2) (Interval j1 j2) <->
  x \in Interval i1 i2 /\ x \in Interval j1 j2.
Proof.
split.
  rewrite /= 3!itv_boundlr joinEtotal meetEtotal le_maxl le_minr.
  by move=> /andP[/andP[-> ->] /andP[-> ->]].
case; rewrite 2!itv_boundlr => /andP[i1x xi2] /andP[j1x xj2].
by rewrite /= itv_boundlr joinEtotal meetEtotal le_maxl le_minr i1x j1x xj2 xi2.
Qed.

Coercion pair_of_interval T (I : interval T) : itv_bound T * itv_bound T :=
  let: Interval b1 b2 := I in (b1, b2).

Definition miditv (R : numDomainType) (i : interval R) : R :=
  match i with
  | Interval (BSide _ a) (BSide _ b) => (a + b) / 2
  | Interval -oo%O (BSide _ b) => b - 1
  | Interval (BSide _ a) +oo%O => a + 1
  | Interval -oo%O +oo%O => 0
  | _ => 0
  end.

Section miditv_lemmas.
Variable R : numFieldType.
Implicit Types i : interval R.

Lemma mem_miditv i : (i.1 < i.2)%O -> miditv i \in i.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= ab; rewrite in_itv /=.
- by rewrite midf_lt // andbT midf_le // ltW.
- by rewrite midf_le // midf_le.
- by rewrite ler_addl ler01.
- by rewrite midf_lt // midf_lt.
- by rewrite midf_lt // midf_le // ltW.
- by rewrite ltr_addl ltr01.
- by rewrite ltr_subl_addr ltr_addl.
- by rewrite ler_subl_addr ler_addl.
Qed.

Lemma miditv_bnd2 i : (i.1 < i.2)%O -> forall b, (BSide b (miditv i) <= i.2)%O.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= => ab; case; rewrite lte_bnd.
- by rewrite midf_le // ltW.
- by rewrite midf_lt.
- by rewrite midf_le.
- by rewrite midf_le.
- by rewrite midf_le // ltW.
- by rewrite midf_lt.
- by rewrite midf_le // ltW.
- by rewrite midf_le // ltW.
- by rewrite ler_subl_addl ler_addr.
- by rewrite ltr_subl_addl ltr_addr.
- by rewrite ler_subl_addl ler_addr.
- by rewrite ler_subl_addl ler_addr.
Qed.

Lemma miditv_bnd1 i : (i.1 < i.2)%O -> forall b, (i.1 <= BSide b (miditv i))%O.
Proof.
move: i => [[[]a|[]] [[]b|[]]] //= => ab; case; rewrite lte_bnd.
- by rewrite midf_le // ltW.
- by rewrite midf_le // ltW.
- by rewrite midf_le.
- by rewrite midf_le.
- by rewrite ler_addl.
- by rewrite ler_addl.
- by rewrite midf_lt.
- by rewrite midf_le // ltW.
- by rewrite midf_lt.
- by rewrite midf_le // ltW.
- by rewrite ltr_addl.
- by rewrite ler_addl.
Qed.

End miditv_lemmas.

(* definitions and lemmas to make a bridge between MathComp intervals and     *)
(* classical sets                                                             *)
Section set_itv_porderType.
Variables (d : unit) (T : porderType d).
Implicit Types (i j : interval T) (x y : T) (a : itv_bound T).

Definition neitv i := [set` i] != set0.

Lemma neitv_lt_bnd i : neitv i -> (i.1 < i.2)%O.
Proof.
case: i => a b; apply: contraNT => /= /itv_ge ab0.
by apply/eqP; rewrite predeqE => t; split => //=; rewrite ab0.
Qed.

Lemma set_itvP i j : [set` i] = [set` j] :> set _ <-> i =i j.
Proof.
split => [ij x|ij]; first by have /(congr1 (@^~ x))/=/is_true_inj := ij.
by rewrite predeqE => r /=; rewrite ij.
Qed.

Lemma subset_itvP i j : {subset i <= j} <-> [set` i] `<=` [set` j].
Proof. by []. Qed.

Lemma set_itvoo x y : `]x, y[%classic = (fun z => x < z < y)%O.
Proof. by []. Qed.

Lemma set_itvoo0 x : `]x, x[%classic = set0.
Proof.
rewrite set_itvoo predeqE => r; split => // /andP[/lt_trans] /[apply].
by rewrite ltxx.
Qed.

Lemma set_itvcc x y : `[x, y]%classic = (fun z => x <= z <= y)%O.
Proof. by []. Qed.

Lemma set_itvoc x y : `]x, y]%classic = (fun z => x < z <= y)%O.
Proof. by []. Qed.

Lemma set_itvoc0 x : `]x, x]%classic = set0.
Proof.
rewrite set_itvoc predeqE => r; split => // /andP[/lt_le_trans] /[apply].
by rewrite ltxx.
Qed.

Lemma set_itvco x y : `[x, y[%classic = (fun z => x <= z < y)%O.
Proof. by []. Qed.

Lemma set_itvco0 x : `[x, x[%classic = set0.
Proof.
rewrite set_itvco predeqE => r; split => // /andP[/le_lt_trans] /[apply].
by rewrite ltxx.
Qed.

Lemma set_itv_infty_infty : `]-oo, +oo[%classic = @setT T.
Proof. by rewrite predeqE. Qed.

Lemma set_itv_o_infty x : `]x, +oo[%classic = (fun z => x < z)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv andbT. Qed.

Lemma set_itv_c_infty x : `[x, +oo[%classic = (fun z => x <= z)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv andbT. Qed.

Lemma set_itv_infty_o x : `]-oo, x[%classic = (fun z => z < x)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv. Qed.

Lemma set_itv_infty_c x : `]-oo, x]%classic = (fun z => z <= x)%O.
Proof. by rewrite predeqE /mkset => r; rewrite in_itv. Qed.

Lemma set_itv_pinfty_bnd a : [set` Interval +oo%O a] = set0.
Proof. by apply/eqP/negPn/negP => /neitv_lt_bnd. Qed.

Lemma set_itv_bnd_ninfty a : [set` Interval a -oo%O] = set0.
Proof. by apply/eqP/negPn/negP => /neitv_lt_bnd /=; case: a => [[]a|[]]. Qed.

Definition set_itv_infty_set0 := (set_itv_bnd_ninfty, set_itv_pinfty_bnd).

Definition set_itvE := (set_itvoo0, set_itvoc0, set_itvco0, set_itvoo,
  set_itvcc, set_itvoc, set_itvco, set_itv_infty_infty, set_itv_o_infty,
  set_itv_c_infty, set_itv_infty_o, set_itv_infty_c, set_itv_infty_set0).

(* puncture interval *)
Lemma punct_itvoc x y : (x < y)%O -> (`]x, y] = `]x, y[ `|` [set y])%classic.
Proof.
move=> xy; rewrite !set_itvE predeqE => r; split=> [/andP[xr]|].
  by rewrite le_eqVlt => /predU1P[->|ry]; [right|left; rewrite xr].
by case=> [/andP[ar /ltW ->]|->]; [rewrite andbT|rewrite xy lexx].
Qed.

Lemma punct_itvco x y : (x < y)%O -> (`[x, y[ = [set x] `|` `]x, y[)%classic.
Proof.
move=> xy; rewrite !set_itvE predeqE => r; split=> [/andP[]|].
  by rewrite le_eqVlt => /predU1P[->|xr ry]; [left|right; rewrite xr].
by case=> [->|/andP[/ltW -> -> //]]; rewrite lexx.
Qed.

Lemma punct_itvccL x y : (x <= y)%O -> (`[x, y] = [set x] `|` `]x, y])%classic.
Proof.
move=> ab; rewrite !set_itvE predeqE => r; split=> [/andP[]|].
  by rewrite le_eqVlt => /predU1P[->|xr ry]; [left|right; rewrite xr].
by case=> [->|/andP[/ltW -> -> //]]; rewrite lexx.
Qed.

Lemma punct_itvccR x y : (x <= y)%O -> (`[x, y] = `[x, y[ `|` [set y])%classic.
Proof.
move=> xy; rewrite !set_itvE predeqE => r; split=> [/andP[xr]|].
  by rewrite le_eqVlt => /predU1P[->|ry]; [right|left; rewrite xr].
by case=> [/andP[-> /ltW //]|->]; rewrite lexx xy.
Qed.

Lemma punct_itv_c_infty x : (`[x, +oo[ = [set x] `|` `]x, +oo[ )%classic.
Proof.
rewrite predeqE => r; rewrite !set_itvE; split; last by case=> [->//|/ltW].
by rewrite le_eqVlt => /predU1P[->|?]; [left|right].
Qed.

Lemma punct_itv_infty_c x : (`]-oo, x] = `]-oo, x[ `|` [set x])%classic.
Proof.
rewrite predeqE => r; rewrite !set_itvE; split => [|[/ltW //|-> //=]].
by rewrite le_eqVlt => /predU1P[->|xr]; [right|left].
Qed.

End set_itv_porderType.
Arguments neitv {d T} _.

Section set_itv_numFieldType.
Variable R : numFieldType.
Implicit Types i : interval R.

Lemma neitvE i : neitv i = (i.1 < i.2)%O.
Proof.
apply/idP/idP; first exact: neitv_lt_bnd.
by move=> /mem_miditv ii; apply/set0P; exists (miditv i).
Qed.

Lemma neitvP i : reflect (i.1 < i.2)%O (neitv i).
Proof. by apply: (iffP idP); rewrite -neitvE. Qed.

End set_itv_numFieldType.

Lemma setitv0 (R : realDomainType) : [set` (0%O : interval R)] = set0.
Proof. by rewrite predeqE. Qed.

Section interval_has_bound.
Variable R : numDomainType.

Lemma has_lbound_itv (x : R) b (a : itv_bound R) :
  has_lbound [set` Interval (BSide b x) a].
Proof. by case: b; exists x => r /andP[]; rewrite lte_bnd // => /ltW. Qed.

Lemma has_ubound_itv (x : R) b (a : itv_bound R) :
  has_ubound [set` Interval a (BSide b x)].
Proof. by case: b; exists x => r /andP[]; rewrite lte_bnd // => _ /ltW. Qed.

End interval_has_bound.

Section interval_hasNbound.
Variable R : realDomainType.

Lemma hasNlbound_itv (a : itv_bound R) : a != -oo%O ->
  ~ has_lbound [set` Interval -oo%O a].
Proof.
move: a => [b r|[|]] _ //.
  suff: ~ has_lbound `]-oo, r[%classic.
    by case: b => //; apply/contra_not/subset_has_lbound => x /ltW.
  apply/has_lbPn => x; exists (minr (r - 1) (x - 1)).
    by rewrite !set_itvE lt_minl ltr_subl_addr ltr_addl ltr01.
  by rewrite lt_minl orbC ltr_subl_addr ltr_addl ltr01.
case=> r /(_ (r - 1)) /=; rewrite in_itv /= => /(_ erefl).
by apply/negP; rewrite -ltNge ltr_subl_addr ltr_addl.
Qed.

Lemma hasNubound_itv (a : itv_bound R) : a != +oo%O ->
  ~ has_ubound [set` Interval a +oo%O].
Proof.
move: a => [b r|[|]] _ //.
  suff: ~ has_ubound `]r, +oo[%classic.
    case: b => //; apply/contra_not/subset_has_ubound => x.
    by rewrite !set_itvE => /ltW.
  apply/has_ubPn => x; rewrite !set_itvE; exists (maxr (r + 1) (x + 1));
  by rewrite ?in_itv /= ?andbT lt_maxr ltr_addl ltr01 // orbT.
case=> r /(_ (r + 1)) /=; rewrite in_itv /= => /(_ erefl).
by apply/negP; rewrite -ltNge ltr_addl.
Qed.

End interval_hasNbound.

Hint Extern 0 (has_lbound _) => solve[apply: has_lbound_itv] : core.
Hint Extern 0 (has_ubound _) => solve[apply: has_ubound_itv] : core.
Hint Extern 0 (~ has_lbound _) => solve[by apply: hasNlbound_itv] : core.
Hint Extern 0 (~ has_ubound _) => solve[by apply: hasNubound_itv] : core.

Section interval_has.
Variable R : realType.
Implicit Types x : R.

Lemma has_sup_half x b (i : itv_bound R) : (i < BSide b x)%O ->
  has_sup [set` Interval i (BSide b x)].
Proof.
move: b i => [] [[]y|[]]; rewrite ?lte_bnd => xy; split=> //; do 1?[
  by exists ((x + y) / 2); rewrite !set_itvE addrC !(midf_le,midf_lt) //;
    exact: ltW
| by exists (x - 1); rewrite !set_itvE
    !(ltr_subl_addr, ler_subl_addr, ltr_addl,ler_addl)].
Qed.

Lemma has_inf_half x b (i : itv_bound R) : (BSide b x < i)%O ->
  has_inf [set` Interval (BSide b x) i].
Proof.
move: b i => [] [[]y|[]]; rewrite ?lte_bnd => xy; do 1?[
  by (split=> //; exists ((x + y) / 2); rewrite !set_itvE !(midf_le,midf_lt) //;
    exact: ltW)
| (by split => //; exists (x + 1); rewrite !set_itvE !(ltr_addl,ler_addl))].
Qed.

End interval_has.

Hint Extern 0 (has_sup _) => solve[apply: has_sup1 | exact: has_sup_half] : core.
Hint Extern 0 (has_inf _) => solve[apply: has_inf1 | exact: has_inf_half]: core.

Lemma minus_itv_bnd_infty (R : numDomainType) (x : R) b :
  -%R @` [set` Interval (BSide b x) +oo%O] =
  [set` Interval -oo%O (BSide (negb b) (- x))].
Proof.
rewrite predeqE => /= r; split=> [[y xy <-]|xr].
  by case: b xy; rewrite !in_itv/= andbT (ler_opp2, ltr_opp2).
exists (- r); rewrite ?opprK //.
by case: b xr; rewrite !in_itv/= andbT (ler_oppr, ltr_oppr).
Qed.

Lemma minus_itvoo (R : numDomainType) (x y : R) :
  -%R @` `]x, y[%classic = `](- y), (- x)[%classic.
Proof.
rewrite predeqE => /= r; split => [[{}r + <-]|].
  by rewrite !in_itv/= !ltr_opp2 andbC.
by exists (- r); rewrite ?opprK// !in_itv/= ltr_oppl ltr_oppr andbC.
Qed.

Section interval_sup_inf.
Variable R : realType.
Implicit Types x y : R.

Lemma sup_itv_infty_bnd x b : sup [set` Interval -oo%O (BSide b x)] = x.
Proof.
case: b; last first.
  by rewrite punct_itv_infty_c sup_setU ?sup1// => ? ? ? ->; exact/ltW.
set s := sup _; apply/eqP; rewrite eq_le; apply/andP; split.
- apply sup_le_ub; last by move=> ? /ltW.
  by exists (x - 1); rewrite !set_itvE ltr_subl_addr ltr_addl.
- rewrite leNgt; apply/negP => sx; pose p := (s + x) / 2.
  suff /andP[?]: (p < x) && (s < p) by apply/negP; rewrite -leNgt sup_ub.
  by rewrite !midf_lt.
Qed.

Lemma inf_itv_bnd_infty x b : inf [set` Interval (BSide b x) +oo%O] = x.
Proof.
case: b; last by rewrite /inf minus_itv_bnd_infty sup_itv_infty_bnd opprK.
rewrite punct_itv_c_infty inf_setU ?inf1// => _ b ->.
by rewrite !set_itvE => /ltW.
Qed.

Let sup_itv_o_bnd x y b : x < y ->
  sup [set` Interval (BRight x) (BSide b y)] = y.
Proof.
case: b => xy; last first.
  by rewrite punct_itvoc// sup_setU ?sup1// => ? ? /andP[? /ltW ?] ->.
set B := [set` _]; set A := `]-oo, x]%classic.
rewrite -(@sup_setU _ A B) //.
- rewrite -(sup_itv_infty_bnd y true); congr sup.
  rewrite predeqE => u; split=> [[|/andP[]//]|yu].
  by rewrite /A !set_itvE => /le_lt_trans; apply.
  by have [xu|ux] := ltP x u; [right; rewrite /B !set_itvE xu| left].
- by move=> u v; rewrite /A /B => ? /andP[xv _]; rewrite (le_trans _ (ltW xv)).
Qed.

Lemma sup_itv_bounded x y a b : x < y ->
  sup [set` Interval (BSide a x) (BSide b y)] = y.
Proof.
case: a => xy; last exact: sup_itv_o_bnd.
case: b.
  by rewrite punct_itvco// sup_setU ?sup_itv_o_bnd// => ? ? -> /andP[/ltW].
by rewrite (punct_itvccR (ltW _))// sup_setU ?sup1// => ? ? /andP[_ /ltW ? ->].
Qed.

Lemma sup_itvcc x y : x <= y -> sup `[x, y]%classic = y.
Proof.
by move=> ?; rewrite punct_itvccR// sup_setU ?sup1// => ? ? /andP[_ /ltW ? ->].
Qed.

Let inf_itv_bnd_o x y b : x < y ->
  inf [set` Interval (BSide b x) (BLeft y)] = x.
Proof.
case: b => xy.
  by rewrite punct_itvco// inf_setU ?inf1// => _ ? -> /andP[/ltW].
by rewrite /inf minus_itvoo sup_itv_o_bnd ?opprK // ltr_oppl opprK.
Qed.

Lemma inf_itv_bounded x y a b : x < y ->
  inf [set` Interval (BSide a x) (BSide b y)] = x.
Proof.
case: b => xy; first exact: inf_itv_bnd_o.
case: a.
  by rewrite (punct_itvccL (ltW _))// inf_setU ?inf1// => ? ? -> /andP[/ltW].
by rewrite punct_itvoc// inf_setU ?inf_itv_bnd_o// => ? ? /andP[? /ltW ?] ->.
Qed.

Lemma inf_itvcc x y : x <= y -> inf `[x, y]%classic = x.
Proof.
by move=> ?; rewrite punct_itvccL// inf_setU ?inf1 // => ? ? -> /andP[/ltW].
Qed.

End interval_sup_inf.

(* lemmas between itv and set-theoretic operations *)
Section set_itv_porderType.
Variables (d : unit) (T : orderType d).
Implicit Types (x y : T) (i j : interval T) (b : bool).

Lemma set_itvC_infty_bnd b x :
  ~` [set` Interval -oo%O (BSide b x)] =
  [set` Interval (BSide b x) +oo%O].
Proof.
case: b; rewrite !set_itvE predeqE => r.
by split; rewrite leNgt => /negP.
by split; rewrite ltNge => /negP.
Qed.

Lemma set_itvC_bnd_infty b x :
  ~` [set` Interval (BSide b x) +oo%O] =  [set` Interval -oo%O (BSide b x)].
Proof. by rewrite -set_itvC_infty_bnd setCK. Qed.

Let set_itvC_bounded b0 b1 x y : ~` [set` Interval (BSide b0 x) (BSide b1 y)] =
  [set` Interval -oo%O (BSide b0 x)] `|` [set` Interval (BSide b1 y) +oo%O].
Proof.
move: b0 b1 => [] []; rewrite !set_itvE predeqE => r; split.
by move/negP; rewrite negb_and -ltNge -leNgt => /orP.
by move/orP; rewrite leNgt (ltNge r x) -negb_and => /negP.
by move/negP; rewrite negb_and -2!ltNge => /orP.
by move/orP; rewrite 2!ltNge -negb_and => /negP.
by move/negP; rewrite negb_and -2!leNgt => /orP.
by move/orP; rewrite 2!leNgt -negb_and => /negP.
by move/negP; rewrite negb_and -leNgt -ltNge => /orP.
by move/orP; rewrite leNgt (ltNge y r) -negb_and => /negP.
Qed.

Lemma set_itvC_itv i : ~` [set` i] =
  [set` Interval -oo%O i.1] `|` [set` Interval i.2 +oo%O].
Proof.
case: i => -[[] x|[]] [[] y|[]] /=.
by rewrite set_itvC_bounded.
by rewrite set_itvC_bounded.
by rewrite !set_itvE setUT setC0.
by rewrite set_itvC_bnd_infty !set_itvE setU0.
by rewrite set_itvC_bounded.
by rewrite set_itvC_bounded.
by rewrite !set_itvE setC0 setUT.
by rewrite set_itvC_bnd_infty !set_itvE setU0.
by rewrite set_itvC_infty_bnd !set_itvE set0U.
by rewrite set_itvC_infty_bnd !set_itvE set0U.
by rewrite set_itvE setC0 set0U set_itvE.
by rewrite !set_itvE setCT set0U.
by rewrite !set_itvE setTU setC0.
by rewrite !set_itvE setTU setC0.
by rewrite !set_itvE setC0 setTU.
by rewrite !set_itvE setC0 setU0.
Qed.

Definition set_itvC := (set_itvC_infty_bnd, set_itvC_bnd_infty, set_itvC_itv).

Lemma itv_boundedErays a x b y : [set` Interval (BSide a x) (BSide b y)] =
  [set` Interval (BSide a x) +oo%O] `\` [set` Interval (BSide b y) +oo%O].
Proof. by rewrite -[LHS]setCK set_itvC setCU /= set_itvC setDE. Qed.

Lemma set_itv_meet i j : [set` itv_meet i j] = [set` i] `&` [set` j].
Proof.
rewrite eqEsubset; split => x; move: i j => [i1 i2] [j1 j2] /=.
- rewrite itv_boundlr joinEtotal meetEtotal le_maxl le_minr.
  move=> /andP[/andP[i1x j1x] /andP[xi2 xj2]].
  by split; rewrite /= itv_boundlr ?i1x ?xi2 // j1x xj2.
- case; rewrite /= !itv_boundlr => /andP[i1x xi2] /andP[j1x xj2] /=.
  by rewrite joinEtotal meetEtotal le_maxl le_minr i1x xi2 j1x xj2.
Qed.

End set_itv_porderType.

Section set_itv_realType.
Variable R : realType.
Implicit Types x : R.

Lemma set_itvK : {in neitv, cancel (fun i => [set` i]) (@Rhull R)}.
Proof.
move=> [[[] x|[]] [[] y|[]]] /neitvP //;
  rewrite /Rhull /= !(in_itv, inE)/= ?lte_bnd => xy.
- rewrite asboolT// inf_itv_bounded// lexx/= xy asboolT// asboolT//=.
  by rewrite asboolF//= sup_itv_bounded//= ltxx ?andbF.
- by rewrite asboolT// inf_itvcc// ?asboolT// ?sup_itvcc// ?lexx ?xy.
- by rewrite asboolT//= inf_itv_bnd_infty lexx asboolT// asboolF.
- rewrite asboolT// inf_itv_bounded//= ltxx asboolF// asboolT//.
  by rewrite sup_itv_bounded// ltxx andbF asboolF.
  rewrite asboolT // inf_itv_bounded // ltxx asboolF // asboolT //.
  by rewrite sup_itv_bounded // xy lexx asboolT.
- by rewrite asboolT // inf_itv_bnd_infty ltxx asboolF // asboolF.
- by rewrite asboolF // asboolT // sup_itv_infty_bnd ltxx asboolF.
- by rewrite asboolF // asboolT // sup_itv_infty_bnd lexx asboolT.
- by rewrite asboolF // asboolF.
Qed.

Lemma RhullT : Rhull setT = `]-oo, +oo[%R :> interval R.
Proof. by rewrite /Rhull -set_itv_infty_infty asboolF// asboolF. Qed.

Lemma RhullK : {in (@is_interval _ : set (set R)),
  cancel (@Rhull R) (fun i => [set` i])}.
Proof.
move=> X /asboolP iX; rewrite /Rhull /mkset /= predeqE => r.
case: ifPn => /asboolP bX; last first.
  case: ifPn => /asboolP aX; last by rewrite (interval_unbounded_setT _ bX aX).
  rewrite in_itv /= negbK; have [|] := asboolP (X (sup X)) => XsupX /=.
    split => [|Xr].
      rewrite le_eqVlt => /predU1P[->//|rX].
      move/has_lbPn : bX => /(_ r)[y Xy yr].
      by move: (iX _ _ Xy XsupX); apply; rewrite (ltW yr) (ltW rX).
    by rewrite /mkset sup_ub //; exact/asboolP.
  split => [rX|Xr]; last exact: sup_ub_strict.
  by apply: interior_subset; rewrite interval_left_unbounded_interior.
case: ifPn => /asboolP uX.
  have [|] := asboolP (X (inf X)) => XinfX.
    rewrite in_itv /= negbK; have [|] := asboolP (X (sup X)) => XsupX /=.
      split=> [|Xr]; last first.
        by rewrite /mkset sup_ub // andbT inf_lb.
      move => /andP[]; rewrite le_eqVlt => /predU1P[<-//|infXr].
      rewrite le_eqVlt => /predU1P[->//|rsupX]; apply: interior_subset.
      by rewrite interval_bounded_interior //; rewrite /mkset infXr.
    split => [/andP[]|Xr].
      rewrite le_eqVlt => /predU1P[<-//|infXr rsupX]; apply: interior_subset.
      by rewrite interval_bounded_interior //; rewrite /mkset infXr.
    by rewrite /mkset inf_lb //= sup_ub_strict.
  have [|] := asboolP (X (sup X)) => XsupX /=.
    rewrite in_itv /=; split=> [/andP[infXr]|Xr]; last first.
      by rewrite inf_lb_strict // sup_ub.
    rewrite le_eqVlt => /predU1P[->//|rsupX]; apply: interior_subset.
    by rewrite interval_bounded_interior //; rewrite /mkset infXr.
  rewrite in_itv /=; split=> [/andP[infXr rsupX]|Xr]; last first.
    by rewrite inf_lb_strict // sup_ub_strict.
  apply: interior_subset.
  by rewrite interval_bounded_interior //; rewrite /mkset infXr.
rewrite in_itv /=; have [|] := asboolP (X (inf X)) => XinfX /=.
  rewrite andbT; split => [|Xr]; last exact: inf_lb.
  rewrite le_eqVlt => /predU1P[<-//|infXr].
  move/has_ubPn : uX => /(_ r)[y Xy yr].
  by move: (iX _ _ XinfX Xy); apply; rewrite (ltW infXr) (ltW yr).
rewrite andbT.
split=> [infXr|Xr]; last exact: inf_lb_strict.
by apply: interior_subset; rewrite interval_right_unbounded_interior.
Qed.

Lemma itv_c_inftyEbigcap x :
  `[x, +oo[%classic = \bigcap_k `]x - k.+1%:R^-1, +oo[%classic.
Proof.
rewrite predeqE => y; split=> /= [|xy].
  rewrite in_itv /= andbT => xy z _ /=; rewrite in_itv /= andbT ltr_subl_addr.
  by rewrite (le_lt_trans xy) // ltr_addl invr_gt0 ltr0n.
rewrite in_itv /= andbT leNgt; apply/negP => yx.
have {}[k ykx] := ltr_add_invr yx.
have {xy}/= := xy k Logic.I.
by rewrite in_itv /= andbT; apply/negP; rewrite -leNgt ler_subr_addr ltW.
Qed.

Lemma itv_bnd_inftyEbigcup b x : [set` Interval (BSide b x) +oo%O] =
  \bigcup_k [set` Interval (BSide b x) (BLeft k%:R)].
Proof.
rewrite predeqE => y; split=> /=; last first.
  by move=> [n _]/=; rewrite in_itv => /andP[xy yn]; rewrite in_itv /= xy.
rewrite in_itv /= andbT => xy; exists (`|floor y|%N.+1) => //=.
rewrite in_itv /= xy /= -addn1 natrD.
have [y0|y0] := ltP 0 y; last by rewrite (le_lt_trans y0)// ltr_spaddr.
rewrite natr_absz ger0_norm; last by rewrite floor_ge0 ltW.
by rewrite -RfloorE lt_succ_Rfloor.
Qed.

Lemma itv_o_inftyEbigcup x :
  `]x, +oo[%classic = \bigcup_k `[x + k.+1%:R^-1, +oo[%classic.
Proof.
rewrite predeqE => y; split => [|[n _]]/=.
  rewrite in_itv /= andbT => xy.
  have {}[k xky] := ltr_add_invr xy.
  by exists k => //=; rewrite in_itv /= (ltW xky).
rewrite in_itv /= andbT => xny.
by rewrite in_itv /= andbT (lt_le_trans _ xny) // ltr_addl invr_gt0.
Qed.

Lemma set_itv_setT (i : interval R) : [set` i] = setT -> i = `]-oo, +oo[.
Proof.
have [i0  /(congr1 (@Rhull _))|] := boolP (neitv i).
  by rewrite set_itvK// => ->; exact: RhullT.
by rewrite negbK => /eqP ->; rewrite predeqE => /(_ 0)[_]/(_ Logic.I).
Qed.

End set_itv_realType.

Lemma trivIset_set_itv_nth (R : numDomainType) def (s : seq (interval R))
  (D : set nat) : [set` def] = set0 ->
  trivIset D (fun i => [set` nth def s i]) <->
    trivIset D (fun i => nth set0 [seq [set` j] | j <- s] i).
Proof.
move=> def0; split=> /trivIsetP ss; apply/trivIsetP => i j Di Dj ij.
- have [si|si] := ltP i (size s); last first.
    by rewrite (nth_default set0) ?size_map// set0I.
  have [sj|sj] := ltP j (size s); last first.
    by rewrite setIC (nth_default set0) ?size_map// set0I.
  by rewrite (nth_map def) // (nth_map def) // ss.
- have [?|h] := ltP i (size s); last by rewrite (nth_default def h) def0 set0I.
  have [?|h] := ltP j (size s); last by rewrite (nth_default def h) def0 setI0.
  by have := ss _ _ Di Dj ij; rewrite (nth_map def) // (nth_map def).
Qed.
Arguments trivIset_set_itv_nth {R} _ {s}.

Lemma neitv_bnd1 (R : numFieldType) (s : seq (interval R)) :
  all neitv s -> forall i, i \in s -> i.1 != +oo%O.
Proof.
move=> /allP sne [a b] si /=; apply/negP => /eqP boo; move: si.
by rewrite boo => /sne /negP; apply; rewrite set_itv_infty_set0.
Qed.

Lemma neitv_bnd2 (R : numFieldType) (s : seq (interval R)) :
  all neitv s -> forall i, i \in s -> i.2 != -oo%O.
Proof.
move=> /allP sne [a b] si /=; apply/negP => /eqP boo; move: si.
by rewrite boo => /sne /negP; apply; rewrite set_itv_infty_set0.
Qed.


Section itv_diff.
Variable R : realType.
Implicit Types i j : interval R.

(* assumes ~ j <= i *)
Definition itv_diff i j := if ~~ neitv (itv_meet i j) then i
  else
    let: Interval i1 i2 := i in let: Interval j1 j2 := j in
    if (j1 <= i1)%O then
      (if (j2 <= i2)%O then Interval j2 i2 else 0%O)
    else
      (if (j2 <= i2)%O then 0%O else Interval i1 j1).

Lemma set_itv_diff i j :
  (~~ (j <= i)%O) || ((j <= i)%O && (j.1 == i.1)) ->
  [set` itv_diff i j] = [set` i] `\` [set` j].
Proof.
move=> ji.
rewrite /itv_diff; case: ifPn => [ij0|/negPn ij0].
  by apply/esym/setDidPl; rewrite -set_itv_meet; apply/eqP; move/negPn : ij0.
move: i j => [i1 i2] [j1 j2] /= in ji ij0 *.
have [ji1|ji1] := leP j1 i1.
- have [ji2|ji2] := leP j2 i2.
  + rewrite eqEsubset; split=> x /=.
    * rewrite itv_boundlr => /andP[j2x xi2]; split=> /=.
        rewrite itv_boundlr xi2 andbT (@le_trans _ _ j2) // leNgt.
        apply/negP => j2j1; apply/negP : ij0; rewrite joinEtotal meetEtotal.
        by rewrite maxElt ltNge ji1 /= minElt ltNge ji2 /= neitvE /= -leNgt ltW.
      rewrite itv_boundlr => /andP[j1x xj2].
      by have := le_trans xj2 j2x; rewrite lte_bnd ltxx.
    * case; rewrite !itv_boundlr => /andP[i1x xi2] /negP; rewrite xi2 andbT.
      by apply: contraNle; rewrite (le_trans ji1).
  + rewrite set_itvE; apply/esym; rewrite setD_eq0 => x /=; rewrite !itv_boundlr.
    by move=> /andP[i1x xi2]; rewrite (le_trans ji1)// (le_trans xi2)// ltW.
- have [ji2|ji2] := leP j2 i2.
    case/orP: ji => [|/andP[ji]]; last by rewrite gt_eqF.
    by rewrite itv_leEmeet [in X in X -> _]/= (join_l (ltW _))// meet_l// eqxx.
  rewrite eqEsubset; split=> x /=.
  * rewrite itv_boundlr => /andP[i1x xj1]; split.
      rewrite itv_boundlr i1x /= leNgt; apply/negP => i2j1; apply/negP : ij0.
      rewrite meetEtotal minElt ji2 joinEtotal maxElt ji1 neitvE /=.
      by rewrite -leNgt (le_trans _ xj1) // (le_trans (ltW i2j1)).
    rewrite itv_boundlr => /andP[j1x xj2].
    by have := le_trans xj1 j1x; rewrite lte_bnd ltxx.
  * move=> -[]; rewrite itv_boundlr => /andP[i1x xi2].
    rewrite itv_boundlr => /negP; rewrite negb_and -2!ltNge => /orP[xj1|j2x].
      by rewrite itv_boundlr i1x.
    by have := lt_trans (le_lt_trans xi2 ji2) j2x; rewrite ltxx.
Qed.

Lemma set_itv_diffxx i : [set` itv_diff i i] = set0.
Proof. by rewrite set_itv_diff ?setDv// lexx eqxx. Qed.

End itv_diff.

Section disjoint_itv.
Context {R : numDomainType}.

Definition disjoint_itv : rel (interval R) :=
  fun a b => [disjoint [set` a] & [set` b]].

Lemma disjoint_itvxx (i : interval R) : neitv i -> ~~ disjoint_itv i i.
Proof. by move=> i0; rewrite /disjoint_itv/= /disj_set /= setIid. Qed.

Lemma lt_disjoint (i j : interval R) :
  (forall x y, x \in i -> y \in j -> x < y) -> disjoint_itv i j.
Proof.
move=> ij; apply/eqP; rewrite predeqE => x; split => // -[xi xj].
by have := ij _ _ xi xj; rewrite ltxx.
Qed.

End disjoint_itv.

Lemma disjoint_neitv {R : realFieldType} (i j : interval R) :
  disjoint_itv i j <-> ~~ neitv (itv_meet i j).
Proof.
case: i j => [a b] [c d]; rewrite /disjoint_itv/disj_set /= -set_itv_meet.
by split => [/negPn//|?]; apply/negPn.
Qed.

Lemma disj_itv_Rhull {R : realType} (A B : set R) : A `&` B = set0 ->
  is_interval A -> is_interval B -> disjoint_itv (Rhull A) (Rhull B).
Proof.
by move=> AB0 iA iB; rewrite /disjoint_itv RhullK ?inE// RhullK ?inE.
Qed.

Definition contiguous_itv (R : realType) (i j : interval R) : bool :=
  (i.2 == j.1 :> itv_bound R).


Section conv_Rhull.
Variable R : realType.
Implicit Types (a b t r : R) (A : set R).

Lemma N01 t : (0 <= t <= 1) = (0 <= 1 - t <= 1).
Proof.
apply/idP/idP => /andP[t0 t1]; apply/andP; split; first by rewrite subr_ge0.
by rewrite ler_subl_addr addrC -ler_subl_addr subrr.
by move: t1; rewrite ler_subl_addr addrC -ler_subl_addr subrr.
by move: t0; rewrite subr_ge0.
Qed.

Definition conv t a b : R := (1 - t) * a + t * b.

Lemma conv0 a b : conv 0 a b = a.
Proof. by rewrite /conv subr0 mul1r mul0r addr0. Qed.

Lemma conv1 a b : conv 1 a b = b.
Proof. by rewrite /conv subrr mul0r add0r mul1r. Qed.

Lemma convN a b t : conv t a b = conv (1 - t) b a.
Proof. by rewrite /conv opprB addrCA subrr addr0 addrC. Qed.

Lemma le_conv a b t : a <= b -> 0 <= t <= 1 -> a <= conv t a b <= b.
Proof.
move=> ab /andP[].
rewrite le_eqVlt => /predU1P[/esym ->{t} _|t0]; first by rewrite conv0 lexx.
rewrite le_eqVlt => /predU1P[->{t0 t}|t1]; first by rewrite conv1 lexx andbT.
have t1t : 1 - t + t = 1 by rewrite subrK.
rewrite /conv; apply/andP; split.
  by rewrite -{1}(mul1r a) -{1}t1t [in X in X <= _]mulrDl ler_add // ler_pmul2l.
rewrite -{2}(mul1r b) -{2}t1t [in X in _ <= X]mulrDl ler_add // ler_pmul2l //.
by rewrite subr_gt0.
Qed.

Definition factor a b x := (x - a) / (b - a).

Lemma factor01 a b x : a != b -> a <= x -> x <= b -> 0 <= factor a b x <= 1.
Proof.
move=> ab ax xb; rewrite divr_ge0 // ?subr_ge0 // ?(le_trans ax) //=.
by rewrite ler_pdivr_mulr ?mul1r ?ler_sub// subr_gt0 lt_neqAle ab (le_trans ax).
Qed.

Lemma conv_factor a b x : a != b -> conv (factor a b x) a b = x.
Proof.
move=> ab; rewrite /conv -(@divff _ (b - a)) ?subr_eq0 1?eq_sym// -mulrBl.
rewrite opprB addrA subrK mulrAC (mulrAC (x - a)) -mulrDl 2!mulrBl.
rewrite -addrA (addrC (b * a)) -addrA (mulrC a b) subrK.
by rewrite -mulrN addrC -mulrDr -mulrA mulfV ?mulr1 // subr_eq0 eq_sym.
Qed.

Lemma conv_subset_Rhull A :
  [set x | exists a b t, [/\ A a, A b, 0 <= t <= 1 & x = conv t a b]]
    `<=` [set` Rhull A].
Proof.
move=> r -[a [b [t [Aa Ab /andP[t0 t1] ->{r}]]]].
have iRhullA := @interval_is_interval _ (Rhull A).
have [ab|/ltW ba] := leP a b.
  apply: (iRhullA a b); rewrite ?set_itv_mem; try exact/sub_Rhull.
  by rewrite le_conv // t0.
apply: (iRhullA b a); rewrite ?set_itv_mem; try exact/sub_Rhull.
by rewrite convN le_conv => //; rewrite -N01 t0.
Qed.

Lemma Rhull_subset_conv A : A !=set0 -> [set` Rhull A] `<=`
  [set x | exists a b t, [/\ A a, A b, 0 <= t <= 1 & x = conv t a b]].
Proof.
move=> A0 r; rewrite /Rhull; set i : R := inf A; set s : R := sup A.
have [|] := asboolP (has_lbound A) => lA.
- have [|]:= asboolP (has_ubound A) => uA.
  + have [|] := asboolP (A i) => Ai.
    * have [|] := asboolP (A s) => As; rewrite /= in_itv /= => /andP[ir rs].
      - have [si|si] := eqVneq i s.
        + have /eqP <- : i == r by rewrite eq_le {2}si ir.
          by exists i, s, 0; rewrite conv0 lexx ler01.
        + by exists i, s, (factor i s r); rewrite factor01 // conv_factor.
      - pose e := s - r.
        have [u ? seu] : exists2 u, A u & s - e < u.
          by apply sup_adherent; rewrite ?subr_gt0.
        have ? : i < u.
          rewrite (le_lt_trans _ seu)// (le_trans ir)// opprB addrCA subrr.
          by rewrite addr0.
        exists i, u, (factor i u r); rewrite factor01 ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans _ (ltW seu))// /e opprB addrCA subrr addr0.
    * have [|] := asboolP (A s) => As; rewrite /= in_itv /= => /andP[ir rs].
      - pose e := r - i.
        have [l ? lie] : exists2 l, A l & l < i + e.
          by apply inf_adherent; rewrite ?subr_gt0.
        have ? : l < s.
          by rewrite (lt_le_trans lie)// (le_trans _ rs)// addrCA subrr addr0.
        exists l, s, (factor l s r); rewrite factor01// ?conv_factor// ?lt_eqF//.
        by rewrite (le_trans (ltW lie)) // /e addrCA subrr addr0.
      - pose e := ((r - i) `&` (s - r))%O.
        have [u ? seu] : exists2 u, A u & s - e < u.
          by apply sup_adherent; rewrite ?ltxI 2?subr_gt0 ?ir.
        have [l ? lie] : exists2 l, A l & l < i + e.
          by apply inf_adherent; rewrite ?ltxI 2?subr_gt0 ?ir.
        have ? : i + e <= r by rewrite -ler_sub_addl leIx lexx.
        have ? : r <= s - e.
          by rewrite -ler_sub_addr opprK -ler_sub_addl leIx lexx orbT.
        have ? : l < u.
           rewrite (lt_le_trans lie)// (le_trans _ (ltW seu))//.
           by rewrite (@le_trans _ _ r).
        exists l, u, (factor l u r); rewrite factor01// ?conv_factor// ?lt_eqF//.
          by rewrite (le_trans (ltW lie)).
        by rewrite (le_trans _ (ltW seu)).
  + have [|] := asboolP (A i) => /= Ai; rewrite in_itv /= andbT => ir.
    * have [u Au ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
      have ? : i < u by rewrite (le_lt_trans ir).
      exists i, u, (factor i u r).
      by rewrite factor01// ?conv_factor // ?lt_eqF// ltW.
    * pose e := r - i.
      have [l ? lie] : exists2 l, A l & l < i + e
        by apply inf_adherent; rewrite ?subr_gt0.
      have [u ? ru] : exists2 u, A u & r < u
        by move/has_ubPn : uA => /(_ r).
      have ? : l < u by rewrite (lt_le_trans lie) // addrCA subrr addr0 ltW.
      have ? : l <= r by rewrite (le_trans (ltW lie)) // addrCA subrr addr0.
      exists l, u, (factor l u r).
      by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
- have [|] := asboolP (has_ubound A) => uA; last move=> _.
  + have [|] := asboolP (A s) => /= As; rewrite in_itv /= => rs.
    * have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
      have ? : l < s by rewrite (lt_le_trans lr).
      exists l, s, (factor l s r).
      by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
    * pose e := s - r.
      have [u ? seu] : exists2 u, A u & s - e < u.
        by apply sup_adherent; rewrite ?subr_gt0.
      have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
      have ? : l < u.
        rewrite (le_lt_trans _ seu)// (le_trans (ltW lr))// opprB addrCA.
        by rewrite subrr addr0.
      have ? : r <= u.
        by rewrite (le_trans _ (ltW seu))// opprB addrCA subrr addr0.
      exists l, u, (factor l u r).
      by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
  + have [l ? lr] : exists2 l, A l & l < r by move/has_lbPn : lA => /(_ r).
    have [u ? ru] : exists2 u, A u & r < u by move/has_ubPn : uA => /(_ r).
    have ? : l < u by rewrite (lt_trans lr).
    exists l, u, (factor l u r).
    by rewrite factor01// ?conv_factor// ?lt_eqF// ltW.
Qed.

Lemma le_Rhull : {homo (@Rhull R) : A B / (A `<=` B) >-> {subset A <= B}}.
Proof.
move=> A; have [A0 B AB r|/set0P A0 B AB r] := eqVneq A set0.
  by rewrite A0 Rhull0 in_itv /= lt_asym.
move/(Rhull_subset_conv A0) => -[a [b [t [Aa Ab /andP[t0 t1] ->]]]].
by apply/conv_subset_Rhull; exists a, b, t; rewrite t0 t1; split=> //; exact/AB.
Qed.

Lemma neitv_Rhull A : ~~ neitv (Rhull A) -> A = set0.
Proof.
move/negPn/eqP => A0; rewrite predeqE => r; split => // /sub_Rhull.
by rewrite A0.
Qed.

Lemma Rhull_involutive A : Rhull [set` Rhull A] = Rhull A.
Proof.
have [A0|/neitv_Rhull] := boolP (neitv (Rhull A)); first by rewrite set_itvK.
by move=> ->; rewrite ?Rhull0 set_itvE Rhull0.
Qed.

End conv_Rhull.

Coercion ereal_of_itv_bound T (b : itv_bound T) : \bar T :=
  match b with BSide _ y => y%:E | +oo%O => +oo%E | -oo%O => -oo%E end.
Arguments ereal_of_itv_bound T !b.

Lemma le_bnd_ereal (R : realDomainType) (a b : itv_bound R) :
  (a <= b)%O -> (a <= b)%E.
Proof.
move: a b => -[[] a|[]] [bb b|[]] //=; rewrite ?(lee_pinfty,lee_ninfty)//.
  by rewrite BLeft_BSide_leE lee_fin.
by case: bb => //; rewrite BRight_BLeft_leE => /ltW; rewrite lee_fin.
Qed.

Lemma lt_ereal_bnd (R : realDomainType) (a b : itv_bound R) :
  (a < b)%E -> (a < b)%O.
Proof.
by move: a b => -[[] a|[]] [[] b|[]] //=;
  rewrite ?(lee_pinfty,lee_ninfty,lte_fin)// => ab; rewrite lte_bnd ltW.
Qed.

Section hlength.
Local Open Scope ereal_scope.
Variable R : realType.
Implicit Types i j : interval R.

Definition hlength (A : set R) : \bar R := let i := Rhull A in i.2 - i.1.

Lemma hlength0 : hlength (set0 : set R) = 0.
Proof. by rewrite /hlength Rhull0 /= subee. Qed.

Lemma hlength_singleton (r : R) : hlength `[r, r] = 0.
Proof.
rewrite /hlength /= asboolT // sup_itvcc //= asboolT//.
by rewrite asboolT ?inf_itvcc//= ?subee// inE.
Qed.

Lemma hlength_itv i : hlength [set` i] = if i.2 > i.1 then i.2 - i.1 else 0.
Proof.
case: ltP => [/lt_ereal_bnd/neitvP i12|]; first by rewrite /hlength set_itvK.
rewrite le_eqVlt => /orP[|/lt_ereal_bnd i12]; last first.
  rewrite (_ : [set` i] = set0) ?hlength0//.
  by apply/eqP/negPn; rewrite -/(neitv _) neitvE -leNgt (ltW i12).
case: i => -[ba a|[|]] [bb b|[|]] //=.
- rewrite /= => /eqP[->{b}]; move: ba bb => -[] []; try
    by rewrite set_itvE hlength0.
  by rewrite hlength_singleton.
- by move=> _; rewrite set_itvE hlength0.
- by move=> _; rewrite set_itvE hlength0.
Qed.

Lemma hlength_setT : hlength setT = +oo%E :> \bar R.
Proof. by rewrite -set_itv_infty_infty hlength_itv. Qed.

Lemma hlength_finite_fin_num i : neitv i -> hlength [set` i] < +oo ->
  ((i.1 : \bar R) \is a fin_num) /\ ((i.2 : \bar R) \is a fin_num).
Proof.
move: i => [[ba a|[]] [bb b|[]]] /neitvP //=; do ?by rewrite ?set_itvE ?eqxx.
by move=> _; rewrite hlength_itv /= lte_pinfty.
by move=> _; rewrite hlength_itv /= lte_ninfty.
by move=> _; rewrite hlength_itv /=.
Qed.

Lemma finite_hlengthE i : neitv i -> hlength [set` i] < +oo ->
  hlength [set` i] = (fine i.2)%:E - (fine i.1)%:E.
Proof.
move=> i0 ioo; have [ri1 ri2] := hlength_finite_fin_num i0 ioo.
rewrite !fineK// hlength_itv; case: ifPn => //.
rewrite -leNgt le_eqVlt => /predU1P[->|]; first by rewrite subee.
by move/lt_ereal_bnd/ltW; rewrite leNgt; move: i0 => /neitvP => ->.
Qed.

Lemma hlength_infty_bnd b r :
  hlength [set` Interval -oo%O (BSide b r)] = +oo :> \bar R.
Proof. by rewrite hlength_itv /= lte_ninfty. Qed.

Lemma hlength_bnd_infty b r :
  hlength [set` Interval (BSide b r) +oo%O] = +oo :> \bar R.
Proof. by rewrite hlength_itv /= lte_pinfty. Qed.

Lemma pinfty_hlength i : hlength [set` i] = +oo ->
  (exists s r, i = Interval -oo%O (BSide s r) \/ i = Interval (BSide s r) +oo%O)
  \/ i = `]-oo, +oo[.
Proof.
rewrite hlength_itv; case: i => -[ba a|[]] [bb b|[]] //= => [|_|_|].
- by case: ifPn.
- by left; exists ba, a; right.
- by left; exists bb, b; left.
- by right.
Qed.

Lemma hlength_ge0 i : 0 <= hlength [set` i].
Proof.
rewrite hlength_itv; case: ifPn => //; case: (i.1 : \bar _) => [r| |].
- by rewrite suber_ge0//; exact: ltW.
- by rewrite ltNge lee_pinfty.
- by case: (i.2 : \bar _) => //= [r _|]; rewrite lee_pinfty.
Qed.
Local Hint Extern 0 (0%:E <= hlength _) => solve[apply: hlength_ge0] : core.

Lemma hlength_Rhull (A : set R) : hlength [set` Rhull A] = hlength A.
Proof. by rewrite /hlength Rhull_involutive. Qed.

Lemma le_hlength_itv i j : {subset i <= j} -> hlength [set` i] <= hlength [set` j].
Proof.
set I := [set` i]; set J := [set` j].
have [->|/set0P I0] := eqVneq I set0; first by rewrite hlength0 hlength_ge0.
have [J0|/set0P J0] := eqVneq J set0.
  by move/subset_itvP; rewrite -/J J0 subset0 -/I => ->.
move=> /subset_itvP ij; apply: lee_sub => /=.
  have [ui|ui] := asboolP (has_ubound I).
    have [uj /=|uj] := asboolP (has_ubound J); last by rewrite lee_pinfty.
    by rewrite lee_fin le_sup // => r Ir; exists r; split => //; apply: ij.
  have [uj /=|//] := asboolP (has_ubound J).
  by move: ui; have := subset_has_ubound ij uj.
have [lj /=|lj] := asboolP (has_lbound J); last by rewrite lee_ninfty.
have [li /=|li] := asboolP (has_lbound I); last first.
  by move: li; have := subset_has_lbound ij lj.
rewrite lee_fin ler_oppl opprK le_sup// ?has_inf_supN//; last first.
  by case: I0 => x Ix; exists (- x)%R, x.
move=> r [r' Ir' <-{r}]; exists (- r')%R.
by split => //; exists r' => //; apply: ij.
Qed.

Lemma le_hlength : {homo hlength : A B / (A `<=` B) >-> A <= B}.
Proof.
move=> a b /le_Rhull /le_hlength_itv.
by rewrite (hlength_Rhull a) (hlength_Rhull b).
Qed.

End hlength.
Arguments hlength {R}.
Hint Extern 0 (0%:E <= hlength _) => solve[apply: hlength_ge0] : core.

Lemma IntervalE (R : numDomainType) (i : interval R) : i = Interval i.1 i.2.
Proof. by case: i. Qed.

Lemma ereal_mem_Interval (R : realDomainType) (r : R) (a b : itv_bound R) :
  (a < r%:E < b)%E -> r \in Interval a b.
Proof.
move: a b => [[]a|[]] [[]b|[]] //=; rewrite ?lte_fin ?in_itv //= => /andP[] //.
- by move=> /ltW ->.
- by move=> /ltW -> /ltW ->.
- by move=> /ltW ->.
- by move=> -> /ltW.
- by move=> ->.
- by move=> _ /ltW.
Qed.

Lemma Interval_ereal_mem (R : realDomainType) (r : R) (a b : itv_bound R) :
  r \in Interval a b -> (a <= r%:E <= b)%E.
Proof.
move: a b => [[]a|[]] [[]b|[]] //=; rewrite ?lee_fin ?in_itv ?(andbT,andbF) //=.
- by move=> /andP[-> /ltW ->].
- by move=> ->; rewrite lee_pinfty.
- by move=> /andP[/ltW -> /ltW ->].
- by move=> /andP[/ltW ->].
- by move=> /ltW ->; rewrite lee_pinfty.
- by move=> /ltW ->; rewrite lee_ninfty.
- by move=> ->; rewrite lee_ninfty.
- by move=> _; rewrite lee_pinfty lee_ninfty.
Qed.

Section itv_semiAlgebraOfSets.
Variable R : realType.
Implicit Types (I J K : set R).

Local Notation Rconnected := (connected : set (set R)).

Definition itv_diffs I J (K := I `\` J) :=
   if (I \in Rconnected) && (J \in Rconnected) then
     connected_component K @` K else [set K].

Lemma finite_cc_itv_diff I J (K := I `\` J) : connected I -> connected J ->
  finite_set (connected_component K @` K).
Proof.
move=> Iconnected Jconnected; set CC := (X in finite_set X).
pose L b := [set x : R | I x /\ forall y, J y ->
                          if b then (y < x)%R else (x < y)%R].
have Lconnected b : connected (L b) by admit.
have IDJ : I `\` J = L true `|` L false by admit.
have CC0 : CC `|` set0  = [set L true; L false; set0] by admit.
suff: finite_set (CC `|` set0) by apply: sub_finite_set; apply: subsetUl.
by rewrite CC0 !finite_setU; do! split; apply: finite_set1.
Admitted.

Lemma finite_itv_diffs I J : finite_set (itv_diffs I J).
Proof.
rewrite /itv_diffs; case: ifP => // /andP[]; rewrite !inE.
exact: finite_cc_itv_diff.
Qed.
Hint Resolve finite_itv_diffs.

Definition itve_diff I J := fset_set (itv_diffs I J).

Lemma connectedIR : setI_closed (@connected R).
Proof.
move=> I J /connected_intervalP Iitv /connected_intervalP Jitv.
apply/connected_intervalP => x y [Ix Jx] [Iy Jy] z xzy.
by split; [apply: (Iitv x y) | apply: (Jitv x y)].
Qed.

Lemma connected_itv_diff I J K : connected I -> connected J ->
    K \in itve_diff I J -> connected K.
Proof.
move=> Ic Jc; rewrite in_fset_set ?inE//=.
rewrite /itv_diffs; case: ifPn => //= [_|].
  by move=> [x _ <-]; apply: component_connected.
by move=> /nandP[]; rewrite notin_set.
Qed.

Lemma itve_diffE I J :
    I `\` J = \big[setU/set0]_(X <- enum_fset (itve_diff I J)) X.
Proof.
rewrite -bigcup_fset_set//= /itv_diffs.
by case: ifP; rewrite ?connected_component_cover// bigcup_set1.
Qed.

Lemma diff_fsets_disjoint I J K K' :
    is_true (K != K') -> is_true (K \in itve_diff I J) ->
    is_true (K' \in itve_diff I J) -> K `&` K' = set0.
Proof.
rewrite !in_fset_set// ?inE /itv_diffs/=; case: ifP => [|_]; last first.
  by move=> /[swap]-> /[swap]->; rewrite eqxx.
move=> /andP[]; rewrite !inE => Ic Jc + [x IJx +] [y IJy +]/=.
move=> /[swap]<- /[swap]<-; apply: contra_neq_eq => /set0P[z [Kxz Kyz]].
apply/same_connected_component/(connected_component_trans Kxz).
exact/connected_component_sym.
Qed.

Definition itvs : Type := R.

HB.instance Definition _  : isSemiRingOfSets itvs :=
  @isSemiRingOfSets.Build itvs (Pointed.class R)  connected itve_diff
    (@connected0 R) connectedIR connected_itv_diff itve_diffE diff_fsets_disjoint.

Lemma connectedR : connected [set: R]. Proof. exact/connected_intervalP. Qed.

Definition itvs_semiRingOfSets := [the semiRingOfSetsType of itvs].

Lemma hlength_ge0' (I : set itvs) : (0 <= hlength I)%E.
Proof. by rewrite -hlength0 le_hlength. Qed.

Lemma hlength_semi_additive : semi_additive (hlength : set itvs -> _).
Proof.
move=> /= I n Im Itriv UII.
Admitted.

Lemma hlength_sigma_sub_additive : sigma_sub_additive (hlength : set itvs -> _).
Proof.
move=> /= I J Jm Im.
move=> Isub.
Admitted.

Lemma hlength_sigma_finite : sigma_finite [set: itvs] hlength.
Proof.
exists (fun k : nat => `[ (- k%:R)%R, k%:R]%classic).
  apply/esym; rewrite -subTset => /= x _ /=.
  exists `|ceil `|x|%R|%N; rewrite //= in_itv/=.
  rewrite !natr_absz intr_norm -RceilE -ler_norml.
  by rewrite [X in (_ <= X)%R]ger0_norm ?Rceil_ge0// Rceil_ge.
move=> k; split => //; first exact/connected_intervalP/interval_is_interval.
by rewrite hlength_itv/= -EFinB; case: ifP; rewrite lte_pinfty.
Qed.

Canonical hlength_measure : {additive_measure set itvs -> \bar R}
  := AdditiveMeasure (AdditiveMeasure.Axioms (@hlength0 _)
     (@hlength_ge0') hlength_semi_additive).

Let gitvs := g_measurableType (@connected R).

Definition lebesgue_measure : {measure set gitvs -> \bar R} :=
  Hahn_ext_measure hlength_sigma_sub_additive.

End itv_semiAlgebraOfSets.
Arguments lebesgue_measure {R}.

Section lebesgue_measure.
Variable R : realType.
Let gitvs := g_measurableType (@connected R).

Lemma lebesgue_measure_unique (mu : {measure set gitvs -> \bar R}) :
  (forall X, connected X -> hlength X = mu X) ->
  forall X, measurable X -> lebesgue_measure X = mu X.
Proof.
move=> muE X mX; apply: Hahn_ext_unique => //=.
  exact: hlength_sigma_sub_additive.
exact: hlength_sigma_finite.
Qed.

End lebesgue_measure.

Section salgebra_ereal.
Variables (R : realType) (G : set (set R)).
Let measurableTypeR := g_measurableType G.
Let measurableR : set (set R) := @measurable measurableTypeR.

Inductive ps_infty : set \bar R -> Prop :=
| ps_infty0 : ps_infty set0
| ps_ninfty : ps_infty [set -oo]%E
| ps_pinfty : ps_infty [set +oo]%E
| ps_inftys : ps_infty [set -oo; +oo]%E.

Lemma ps_inftyP (A : set \bar R) : ps_infty A <-> A `<=` [set -oo; +oo]%E.
Proof.
split => [[]//|Aoo].
by have [|[|[|]]] := subset_set2 Aoo; move=> ->; constructor.
Qed.

Definition emeasurable : set (set \bar R) :=
  [set EFin @` A `|` B | A in measurableR & B in ps_infty].

Lemma emeasurable0 : emeasurable set0.
Proof.
exists set0; first exact: measurable0.
by exists set0; rewrite ?setU0// ?image_set0//; constructor.
Qed.

Lemma bigcup_EFIn (F : (set R)^nat) : [set x%:E | x in \bigcup_i F i] =
                                    \bigcup_i (EFin @` F i).
Proof.
rewrite eqEsubset; split => [_ [r [n _ Fnr <-]]|]; first by exists n => //; exists r.
by move=> x [n _ [r Fnr <- /=]]; exists r => //; exists n.
Qed.

Lemma setC_EFin (B : set R) : [set x%:E | x in ~` B] =
                               (~` (EFin @` B)) `\` [set -oo%E; +oo%E].
Proof.
rewrite eqEsubset; split => [_ [r Br <-]|[r | |]].
  by split => [|[]//]; apply: contra_not Br => -[? ? [] <-].
- move=> [Br _]; apply/not_exists2P; apply: contra_not Br => h.
  by exists r => //; have [|//] := h r; apply: contrapT.
- by move=> -[_] /not_orP[_ /=].
- by move=> -[_] /not_orP[/=].
Qed.

(* TODO: improve with setC_EFin *)
Lemma setCU_R_ereal (A : set R) (B : set \bar R) : ps_infty B ->
  ~` ([set x%:E | x in A] `|` B) = [set x%:E | x in ~` A] `|` [set -oo%E; +oo%E] `&` ~` B.
Proof.
move=> ps_inftyB; rewrite setCU.
have -> : ~` [set x%:E | x in A] = [set x%:E | x in ~` A] `|` [set -oo; +oo]%E.
  rewrite predeqE => -[x| |]; split.
  - by move=> Ax; left; exists x => //; apply: contra_not Ax => Ax; exists x.
  - by move=> [[r Ar [<-{x}]]|[]//]; apply: contra_not Ar => -[x Ax [<-]].
  - by move=> _; right; right.
  - by move=> [[]|[] _ []].
  - by move=> _; right; left.
  - by move=> [[]|[_ []|]].
rewrite setIUl; congr (_ `|` _).
rewrite predeqE => -[x| |]; split; try by case.
move=> [] x' Ax' [] <-{x}; split; first by exists x'.
by case: ps_inftyB => // -[].
Qed.

Lemma emeasurableC (X : set \bar R) : emeasurable X -> emeasurable (~` X).
Proof.
move => -[A mA] [B PooB <-]; rewrite setCU_R_ereal //.
exists (~` A); [exact: measurableC | exists ([set -oo%E; +oo%E] `&` ~` B) => //].
case: PooB.
- by rewrite setC0 setIT; constructor.
- rewrite setIUl setICr set0U -setDE.
  have [_ ->] := @setDidPl (\bar R) [set +oo%E] [set -oo%E]; first by constructor.
  by rewrite predeqE => x; split => // -[->].
- rewrite setIUl setICr setU0 -setDE.
  have [_ ->] := @setDidPl (\bar R) [set -oo%E] [set +oo%E]; first by constructor.
  by rewrite predeqE => x; split => // -[->].
- by rewrite setICr; constructor.
Qed.

Lemma emeasurable_bigcup (F : (set \bar R)^nat) :
  (forall i, emeasurable (F i)) -> emeasurable (\bigcup_i (F i)).
Proof.
move=> mF; pose P := fun i j => measurableR j.1 /\ ps_infty j.2 /\
                            F i = [set x%:E | x in j.1] `|` j.2.
have [f fi] : {f : nat -> (set R) * (set \bar R) & forall i, P i (f i) }.
  by apply: choice => i; have [x mx [y PSoo'y] xy] := mF i; exists (x, y).
exists (\bigcup_i (f i).1).
  by apply: measurable_bigcup => i; exact: (fi i).1.
exists (\bigcup_i (f i).2).
  apply/ps_inftyP => x [n _] fn2x.
  have /ps_inftyP : ps_infty(f n).2 by have [_ []] := fi n.
  exact.
rewrite [RHS](@eq_bigcupr _ _ _ _
    (fun i => [set x%:E | x in (f i).1] `|` (f i).2)); last first.
  by move=> i; have [_ []] := fi i.
rewrite bigcupU; congr (_ `|` _).
rewrite predeqE => i /=; split=> [[r [n _ fn1r <-{i}]]|[n _ [r fn1r <-{i}]]];
 by [exists n => //; exists r | exists r => //; exists n].
Qed.

Definition ereal_isMeasurable : isMeasurable (\bar R) :=
  isMeasurable.Build _ (Pointed.class _)
    emeasurable0 emeasurableC emeasurable_bigcup.

End salgebra_ereal.

Section puncture_ereal_itv.
Variable R : realDomainType.
Implicit Types (y : R) (b : bool).
Local Open Scope ereal_scope.

Lemma punct_eitv_bnd_pinfty b y : [set` Interval (BSide b y%:E) +oo%O] =
  EFin @` [set` Interval (BSide b y) +oo%O] `|` [set +oo].
Proof.
rewrite predeqE => x; split; rewrite /= in_itv andbT.
- move: x => [x| |] yxb; [|by right|by case: b yxb].
  by left; exists x => //; rewrite in_itv /= andbT; case: b yxb.
- move=> [[r]|->].
  + by rewrite in_itv /= andbT => yxb <-; case: b yxb.
  + by case: b => /=; rewrite ?(lte_pinfty, lee_pinfty).
Qed.

Lemma punct_eitv_ninfty_bnd b y : [set` Interval -oo%O (BSide b y%:E)] =
  [set -oo%E] `|` EFin @` [set x | x \in Interval -oo%O (BSide b y)].
Proof.
rewrite predeqE => x; split; rewrite /= in_itv.
- move: x => [x| |] yxb; [|by case: b yxb|by left].
  by right; exists x => //; rewrite in_itv /= andbT; case: b yxb.
- move=> [->|[r]].
  + by case: b => /=; rewrite ?(lte_ninfty, lee_ninfty).
  + by rewrite in_itv /= => yxb <-; case: b yxb.
Qed.

Lemma punct_eitv_setTR : [set of @EFin R] `|` [set +oo] = [set~ -oo].
Proof.
rewrite eqEsubset; split => [a [[a' _ <-]|->]|]; rewrite ?lte_ninfty//.
by move=> [x| |] //= _; [left; exists x|right].
Qed.

Lemma punct_eitv_setTL : [set of @EFin R] `|` [set -oo] = [set~ +oo].
Proof.
rewrite eqEsubset; split => [a [[a' _ <-]|->]|]; rewrite ?lte_ninfty//.
by move=> [x| |] //= _; [left; exists x|right].
Qed.

End puncture_ereal_itv.

Section salgebra_R_ssets.
Variable R : realType.

Fail Check forall (T : measurableType) (f : T -> R), measurable_fun setT f.

Definition measurableTypeR :=
  g_measurableType (@measurable (@itvs_semiRingOfSets R)).

Definition measurableR : set (set R) := @measurable measurableTypeR.

HB.instance Definition R_isMeasurable : isMeasurable R :=
  isMeasurable.Build measurableTypeR (Pointed.class R)
    measurable0 (@measurableC _) (@measurable_bigcup _).
(*HB.instance (Real.sort R) R_isMeasurable.*)

Check forall (T : measurableType) (f : T -> R), measurable_fun setT f.

Lemma measurable_set1 (r : R) : measurable [set r].
Proof.
apply: g_salgebra_self => /=; apply/connected_intervalP.
by move=> x y -> -> z; rewrite -eq_le => /eqP->.
Qed.

Lemma measurable_itv (i : interval R) : measurable ([set` i]).
Proof. exact/g_salgebra_self/connected_intervalP/interval_is_interval. Qed.

(*HB.instance Definition _ :=
  Rbar_isMeasurable (@measurable (@sset_algebraOfSetsType R)).*)
HB.instance (\bar (Real.sort R))
  (ereal_isMeasurable (@measurable (@itvs_semiRingOfSets R))).
(* NB: this produces a warning but the alternative fails with Coq 8.12 with the
  following message (according to the CI):
  # [redundant-canonical-projection,typechecker]
  # forall (T : measurableType) (f : T -> R), measurable_fun setT f
  #      : Prop
  # File "./theories/lebesgue_measure.v", line 4508, characters 0-88:
  # Error: Anomaly "Uncaught exception Failure("sep_last")."
  # Please report at http://coq.inria.fr/bugs/.
*)

Check forall (T : measurableType) (f : T -> \bar R), measurable_fun setT f.

Lemma measurable_EFin (A : set R) : measurableR A -> measurable (EFin @` A).
Proof.
by move=> mA; exists A => //; exists set0; [constructor|rewrite setU0].
Qed.

Lemma emeasurable_set1 (x : \bar R) : measurable [set x].
Proof.
case: x => [r| |].
- by rewrite -image_set1; exact/measurable_EFin/measurable_set1.
- exists set0 => //; [exists [set +oo%E]; [by constructor|]].
  by rewrite image_set0 set0U.
- exists set0 => //; [exists [set -oo%E]; [by constructor|]].
  by rewrite image_set0 set0U.
Qed.

Lemma itv_cpinfty_pinfty : `[+oo%E, +oo[%classic = [set +oo%E] :> set (\bar R).
Proof.
rewrite set_itvE predeqE => t; split => /= [|<-//].
by rewrite lee_pinfty_eq => /eqP.
Qed.

Lemma itv_opinfty_pinfty : `]+oo%E, +oo[%classic = set0 :> set (\bar R).
Proof.
rewrite set_itvE predeqE => t; split => //=.
by apply/negP; rewrite -leNgt lee_pinfty.
Qed.

Lemma itv_cninfty_pinfty : `[-oo%E, +oo[%classic = setT :> set (\bar R).
Proof.
by rewrite set_itvE predeqE => t; split => //= _; rewrite lee_ninfty.
Qed.

Lemma itv_oninfty_pinfty : `]-oo%E, +oo[%classic = ~` [set -oo]%E :> set (\bar R).
Proof.
rewrite set_itvE predeqE => x; split => /=.
- by move: x => [x| |]; rewrite ?ltxx//.
- by move: x => [x h|//|/(_ erefl)]; rewrite ?lte_ninfty.
Qed.

Lemma emeasurable_itv_bnd_pinfty b (y : \bar R) :
  measurable [set` Interval (BSide b y) +oo%O].
Proof.
move: y => [y| |].
- exists [set` Interval (BSide b y) +oo%O]; first exact: measurable_itv.
  by exists [set +oo%E]; [constructor|rewrite -punct_eitv_bnd_pinfty].
- case: b; last by rewrite itv_opinfty_pinfty.
  by rewrite itv_cpinfty_pinfty; exact: emeasurable_set1.
- case: b; first by rewrite itv_cninfty_pinfty.
  by rewrite itv_oninfty_pinfty; exact/measurableC/emeasurable_set1.
Qed.

Lemma emeasurable_itv_ninfty_bnd b (y : \bar R) :
  measurable [set` Interval -oo%O (BSide b y)].
Proof.
by rewrite -set_itvC_bnd_infty; exact/measurableC/emeasurable_itv_bnd_pinfty.
Qed.

Definition elebesgue_measure' : set \bar R -> \bar R :=
  fun S => lebesgue_measure (fine @` (S `\` [set -oo; +oo]%E)).

Lemma elebesgue_measure'0 : elebesgue_measure' set0 = 0%E.
Proof. by rewrite /elebesgue_measure' set0D image_set0 measure0. Qed.

Lemma measurable_fine (X : set \bar R) : measurable X ->
  measurable [set fine x | x in X `\` [set -oo; +oo]%E].
Proof.
case => Y mY [X' [ | <-{X} | <-{X} | <-{X} ]].
- rewrite setU0 => <-{X}.
  rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    by move=> [x [[x' Yx' <-{x}/= _ <-//]]].
  by move=> Yr; exists r%:E; split => [|[]//]; exists r.
- rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    move=> [x [[[x' Yx' <- _ <-//]|]]].
    by move=> <-; rewrite not_orP => -[]/(_ erefl).
  by move=> Yr; exists r%:E => //; split => [|[]//]; left; exists r.
- rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    move=> [x [[[x' Yx' <-{x} _ <-//]|]]].
    by move=> ->; rewrite not_orP => -[_]/(_ erefl).
  by move=> Yr; exists r%:E => //; split => [|[]//]; left; exists r.
- rewrite [X in measurable X](_ : _ = Y) // predeqE => r; split.
    by rewrite setDUl setDv setU0 => -[_ [[x' Yx' <-]] _ <-].
  by move=> Yr; exists r%:E => //; split => [|[]//]; left; exists r.
Qed.

Lemma elebesgue_measure'_ge0 X : (0 <= elebesgue_measure' X)%E.
Proof. exact/measure_ge0. Qed.

Lemma semi_sigma_additive_elebesgue_measure' :
  semi_sigma_additive elebesgue_measure'.
Proof.
move=> /= F mF tF mUF; rewrite /elebesgue_measure'.
rewrite [X in lebesgue_measure X](_ : _ =
    \bigcup_n (fine @` (F n `\` [set -oo; +oo]%E))); last first.
  rewrite predeqE => r; split.
    by move=> [x [[n _ Fnx xoo <-]]]; exists n => //; exists x.
  by move=> [n _ [x [Fnx xoo <-{r}]]]; exists x => //; split => //; exists n.
apply: (@measure_semi_sigma_additive _ _ (@lebesgue_measure R)
  (fun n => fine @` (F n `\` [set -oo; +oo]%E))).
- move=> n; have := mF n.
  move=> [X mX [X' mX']] XX'Fn.
  apply: measurable_fine.
  rewrite -XX'Fn.
  apply: measurableU; first exact: measurable_EFin.
  case: mX'; [by [] |exact: emeasurable_set1
                    |exact: emeasurable_set1|].
  by apply: measurableU; exact: emeasurable_set1.
- move=> i j _ _ [x [[a [Fia aoo ax] [b [Fjb boo] bx]]]].
  move: tF => /(_ i j Logic.I Logic.I); apply.
  suff ab : a = b by exists a; split => //; rewrite ab.
  move: a b {Fia Fjb} aoo boo ax bx.
  move=> [a| |] [b| |] /=.
  + by move=> _ _ -> ->.
  + by move=> _; rewrite not_orP => -[_]/(_ erefl).
  + by move=> _; rewrite not_orP => -[]/(_ erefl).
  + by rewrite not_orP => -[_]/(_ erefl).
  + by rewrite not_orP => -[_]/(_ erefl).
  + by rewrite not_orP => -[_]/(_ erefl).
  + by rewrite not_orP => -[]/(_ erefl).
  + by rewrite not_orP => -[]/(_ erefl).
  + by rewrite not_orP => -[]/(_ erefl).
- move: mUF.
  rewrite {1}/measurable /emeasurable /= => -[X mX [Y []]] {Y}.
  - rewrite setU0 => h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-{r}]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[x' Xx' <-].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
  - move=> h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[[x' Xx' <-//]|xoo']; move/not_orP : xoo => -[].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; left; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
  - (* NB: almost the same as the previous one, factorize?*)
    move=> h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[[x' Xx' <-//]|xoo']; move/not_orP : xoo => -[].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; left; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
  - move=> h.
    rewrite [X in measurable X](_ : _ = X) // predeqE => r; split => [|Xr].
      move=> -[n _ [x [Fnx xoo <-]]].
      have : (\bigcup_n F n) x by exists n.
      by rewrite -h => -[[x' Xx' <-//]|].
    have [n _ Fnr] : (\bigcup_n F n) r%:E by rewrite -h; left; exists r.
    by exists n => //; exists r%:E => //; split => //; case.
Qed.

Definition elebesgue_measure_isMeasure : is_measure elebesgue_measure' :=
  Measure.Axioms elebesgue_measure'0 elebesgue_measure'_ge0
                 semi_sigma_additive_elebesgue_measure'.

Definition elebesgue_measure : {measure set \bar R -> \bar R} :=
  Measure.Pack _ elebesgue_measure_isMeasure.

End salgebra_R_ssets.

(* TODO: move *)
Lemma preimage_itv T (d : unit) (rT : porderType d) (f : T -> rT) (i : interval rT) (x : T) :
  ((f @^-1` [set` i]) x) = (f x \in i).
Proof. by rewrite inE. Qed.

Lemma preimage_itv_o_infty T (d : unit) (rT : porderType d) (f : T -> rT) y :
  f @^-1` `]y, +oo[%classic = [set x | (y < f x)%O].
Proof.
by rewrite predeqE => t; split => /= [|?]; rewrite preimage_itv in_itv/= andbT.
Qed.

Lemma preimage_itv_c_infty T (d : unit) (rT : porderType d) (f : T -> rT) y :
  f @^-1` `[y, +oo[%classic = [set x | (y <= f x)%O].
Proof.
by rewrite predeqE => t; split => [|?]; rewrite preimage_itv in_itv/= andbT.
Qed.

Lemma preimage_itv_infty_o T (d : unit) (rT : orderType d) (f : T -> rT) y :
  f @^-1` `]-oo, y[%classic = [set x | (f x < y)%O].
Proof. by rewrite predeqE => t; split => [|?]; rewrite preimage_itv in_itv. Qed.

Lemma preimage_itv_infty_c T (d : unit) (rT : orderType d) (f : T -> rT) y :
  f @^-1` `]-oo, y]%classic = [set x | (f x <= y)%O].
Proof. by rewrite predeqE => t; split => [|?]; rewrite preimage_itv in_itv. Qed.

Section measurable_fun_measurable.
Local Open Scope ereal_scope.
Variables (T : measurableType) (R : realType) (D : set T) (f : T -> \bar R).
Hypotheses (mD : measurable D) (mf : measurable_fun D f).
Implicit Types y : \bar R.

Lemma emeasurable_fun_c_infty y : measurable (D `&` [set x | y <= f x]).
Proof.
by rewrite -preimage_itv_c_infty; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma emeasurable_fun_o_infty y :  measurable (D `&` [set x | y < f x]).
Proof.
by rewrite -preimage_itv_o_infty; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma emeasurable_fun_infty_o y : measurable (D `&` [set x | f x < y]).
Proof.
by rewrite -preimage_itv_infty_o; exact/mf/emeasurable_itv_ninfty_bnd.
Qed.

Lemma emeasurable_fun_infty_c y : measurable (D `&` [set x | f x <= y]).
Proof.
by rewrite -preimage_itv_infty_c; exact/mf/emeasurable_itv_ninfty_bnd.
Qed.

Lemma emeasurable_fin_num : measurable (D `&` [set x | f x \is a fin_num]).
Proof.
rewrite [X in measurable X](_ : _ =
  \bigcup_k (D `&` ([set  x | - k%:R%:E <= f x] `&` [set x | f x <= k%:R%:E]))).
  apply: measurable_bigcup => k; rewrite -(setIid D) setIACA.
  by apply: measurableI; [exact: emeasurable_fun_c_infty|
                          exact: emeasurable_fun_infty_c].
rewrite predeqE => t; split => [/= [Dt ft]|].
  have [ft0|ft0] := leP 0%R (fine (f t)).
    exists `|ceil (fine (f t))|%N => //=; split => //; split.
      by rewrite -{2}(fineK ft)// lee_fin (le_trans _ ft0)// ler_oppl oppr0.
    by rewrite natr_absz ger0_norm ?ceil_ge0// -(fineK ft) lee_fin ceil_ge.
  exists `|floor (fine (f t))|%N => //=; split => //; split.
    rewrite natr_absz ltr0_norm ?floor_lt0// EFinN.
    by rewrite -{2}(fineK ft) lee_fin mulrNz opprK floor_le.
  by rewrite -(fineK ft)// lee_fin (le_trans (ltW ft0)).
move=> [n _] [/= Dt [nft fnt]]; split => //; rewrite fin_numElt.
by rewrite (lt_le_trans _ nft) ?lte_ninfty//= (le_lt_trans fnt)// lte_pinfty.
Qed.

Lemma emeasurable_neq y : measurable (D `&` [set x | f x != y]).
Proof.
rewrite (_ : [set x | f x != y] = f @^-1` (setT `\ y)); last first.
  rewrite predeqE => t; split.
    by rewrite /= => ft0; rewrite /preimage /=; split => //; exact/eqP.
  by rewrite /preimage /= => -[_ /eqP].
by apply/mf/measurableD => //; exact/emeasurable_set1.
Qed.

End measurable_fun_measurable.

Module RGenOInfty.
Section rgenoinfty.
Variable R : realType.
Implicit Types x y z : R.

Definition G := [set A | exists x, A = `]x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval (BSide b x) +oo%O].
Proof.
case: b; last by apply g_salgebra_self; eexists; reflexivity.
rewrite itv_c_inftyEbigcap; apply: measurable_bigcap => i.
by apply g_salgebra_self; eexists; reflexivity.
Qed.

Lemma measurable_itv_bounded a b x : a != +oo%O ->
  @measurable T [set` Interval a (BSide b x)].
Proof.
case: a => [a r _|[_|//]].
  rewrite itv_boundedErays; apply/measurableD => //;
    exact: measurable_itv_bnd_infty.
by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_bnd_infty.
Qed.

Lemma measurableE :
  @measurable (g_measurableType (measurable : set (set (itvs R)))) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  apply: subset_g_salgebra => A' /= [x ->].
  exact/connected_intervalP/interval_is_interval.
apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra.
move=> I /connected_intervalP/is_intervalP->.
case: Rhull => [[xb x|xb] [yb y|yb]]//=.
  under eq_set do rewrite itv_splitI//=.


(* move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil. *)
(* rewrite /sset big_cons; apply: measurableU => //. *)
(* by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve *)
(*   [exact: measurable_itv_bounded | exact: measurable_itv_bnd_infty | *)
(*    by rewrite set_itvE]. *)
(* Qed. *)
Admitted.

End rgenoinfty.
End RGenOInfty.

Module RGenInftyO.
Section rgeninftyo.
Variable R : realType.
Implicit Types x y z : R.

Definition G := [set A | exists x, A = `]-oo, x[%classic].
Let T := g_measurableType G.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval -oo%O (BSide b x)].
Proof.
case: b; last first.
  rewrite -[X in measurable X]setCK set_itvC itv_o_inftyEbigcup.
  apply/measurableC/measurable_bigcup => n; rewrite -[X in measurable X]setCK.
  apply: measurableC; rewrite set_itvC.
  by apply: g_salgebra_self; eexists; reflexivity.
by apply g_salgebra_self; eexists; reflexivity.
Qed.

Lemma measurable_itv_bounded a b x : a != -oo%O ->
  @measurable T [set` Interval (BSide b x) a].
Proof.
case: a => [a r _|[//|_]].
  rewrite itv_boundedErays; apply/measurableD => //;
    rewrite -[X in measurable X]setCK; apply: measurableC; rewrite set_itvC;
    exact: measurable_itv_bnd_infty.
by rewrite -set_itvC_infty_bnd; exact/measurableC/measurable_itv_bnd_infty.
Qed.

Lemma measurableE :
  @measurable (g_measurableType (measurable : set (set (itvs R)))) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
(*   apply: subset_g_salgebra => A' /= [x ->]; exists [:: `]-oo, x[ ]. *)
(*   by rewrite /sset big_cons big_nil setU0. *)
(* apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra. *)
(* move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil. *)
(* rewrite /sset big_cons; apply: measurableU => //. *)
(* by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve *)
(*   [exact: measurable_itv_bounded | exact: measurable_itv_bnd_infty | *)
(*    by rewrite set_itvE]. *)
Admitted.

End rgeninftyo.
End RGenInftyO.

Module RGenCInfty.
Section rgencinfty.
Variable R : realType.
Implicit Types x y z : R.

Definition G : set (set R) := [set A | exists x, A = `[x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval (BSide b x) +oo%O].
Proof.
case: b; first by apply: g_salgebra_self; exists x; rewrite set_itv_c_infty.
rewrite itv_o_inftyEbigcup; apply: measurable_bigcup => i.
by apply: g_salgebra_self; eexists; reflexivity.
Qed.

Lemma measurable_itv_bounded a b y : a != +oo%O ->
  @measurable T [set` Interval a (BSide b y)].
Proof.
case: a => [a r _|[_|//]].
  rewrite itv_boundedErays.
  by apply: measurableD; apply: measurable_itv_bnd_infty.
by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_bnd_infty.
Qed.

Lemma measurableE :
  @measurable (g_measurableType (measurable : set (set (itvs R)))) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
(*   apply: subset_g_salgebra => B /= [x ->]; exists [:: `[x, +oo[ ]. *)
(*   by rewrite /sset big_cons big_nil setU0 set_itv_c_infty. *)
(* apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra. *)
(* move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil. *)
(* rewrite /sset big_cons; apply: measurableU => //. *)
(* by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve *)
(*   [exact: measurable_itv_bounded | exact: measurable_itv_bnd_infty | *)
(*    by rewrite set_itvE]. *)
(* Qed. *)
Admitted.

End rgencinfty.
End RGenCInfty.

Module RGenOpens.
Section rgenopens.

Variable R : realType.
Implicit Types x y z : R.

Definition G := [set A | exists x y, A = `]x, y[%classic].
Let T := g_measurableType G.

Local Lemma measurable_itvoo x y : @measurable T `]x, y[%classic.
Proof. by apply g_salgebra_self; eexists; eexists; reflexivity. Qed.

Local Lemma measurable_itv_o_infty x : @measurable T `]x, +oo[%classic.
Proof.
rewrite itv_bnd_inftyEbigcup; apply: measurable_bigcup => i.
exact: measurable_itvoo.
Qed.

Lemma measurable_itv_bnd_infty b x :
  @measurable T [set` Interval (BSide b x) +oo%O].
Proof.
case: b; last exact: measurable_itv_o_infty.
rewrite itv_c_inftyEbigcap; apply: measurable_bigcap => i.
exact/measurable_itv_o_infty.
Qed.

Lemma measurable_itv_infty_bnd b x :
  @measurable T [set` Interval -oo%O (BSide b x)].
Proof.
case: b.
- by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_bnd_infty.
- by rewrite -set_itvC_bnd_infty; exact/measurableC/measurable_itv_o_infty.
Qed.

Lemma measurable_itv_bounded a x b y :
  @measurable T [set` Interval (BSide a x) (BSide b y)].
Proof.
move: a b => [] []; rewrite -[X in measurable X]setCK set_itvC_itv;
  apply: measurableC; apply: measurableU; try solve[
    exact: measurable_itv_infty_bnd|exact: measurable_itv_bnd_infty].
Qed.

Lemma measurableE :
  @measurable (g_measurableType (measurable : set (set (itvs R)))) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
(*   apply: subset_g_salgebra => B /= [x [y ->]]; exists [:: `]x, y[ ]. *)
(*   by rewrite /sset big_cons big_nil setU0. *)
(* apply: g_salgebra_smallest; last by apply: are_measurable_sets_g_salgebra. *)
(* move=> _ [s ->] {A}; elim: s => [|h t ih]; first by rewrite /sset big_nil. *)
(* rewrite /sset big_cons; apply: measurableU => //. *)
(* by move: h => [[a x|a] [b y|b]]; move: a b => [] []; solve[ *)
(*   exact: measurable_itv_bounded | exact: measurable_itv_infty_bnd | *)
(*   exact: measurable_itv_bnd_infty | by rewrite set_itvE]. *)
Admitted.

End rgenopens.
End RGenOpens.

Section erealwithrays.
Variable R : realType.
Implicit Types (x y z : \bar R) (r s : R).
Local Open Scope ereal_scope.

Lemma EFin_itv_bnd_infty b r : EFin @` [set` Interval (BSide b r) +oo%O] =
  [set` Interval (BSide b r%:E) +oo%O] `\ +oo.
Proof.
rewrite eqEsubset; split => [x [s /itvP rs <-]|x []].
  split => //=; rewrite in_itv /=.
  by case: b in rs *; rewrite /= ?(lee_fin, lte_fin) rs.
move: x => [s|_ /(_ erefl)|] //=; rewrite in_itv /= andbT; last first.
  by case: b => /=; rewrite 1?(leNgt,ltNge) 1?(lte_ninfty,lee_ninfty).
by case: b => /=; rewrite 1?(lte_fin,lee_fin) => rs _;
  exists s => //; rewrite in_itv /= rs.
Qed.

Lemma EFin_itv r : [set s | r%:E < s%:E] = `]r, +oo[%classic.
Proof.
by rewrite predeqE => s; split => [|]; rewrite /= lte_fin in_itv/= andbT.
Qed.

Lemma preimage_EFin_setT : @EFin R @^-1` [set x | x \in `]-oo%E, +oo[] = setT.
Proof.
by rewrite set_itvE predeqE => r; split=> // _; rewrite /preimage /= lte_ninfty.
Qed.

Lemma eitv_c_infty r : `[r%:E, +oo[%classic =
  \bigcap_k `](r - k.+1%:R^-1)%:E, +oo[%classic :> set _.
Proof.
rewrite predeqE => x; split=> [|].
- move: x => [s /=| _ n _|//].
  + rewrite in_itv /= andbT lee_fin => rs n _ /=.
    rewrite in_itv /= andbT lte_fin.
    by rewrite ltr_subl_addl (le_lt_trans rs)// ltr_addr invr_gt0.
  + by rewrite /= in_itv /= andbT lte_pinfty.
- move: x => [s| |/(_ 0%N Logic.I)] //=; last by rewrite in_itv /= lee_pinfty.
  move=> h; rewrite in_itv /= lee_fin leNgt andbT; apply/negP.
  move=> /ltr_add_invr[k skr]; have {h} := h k Logic.I.
  rewrite /= in_itv /= andbT lte_fin ltNge => /negP; apply.
  by rewrite -ler_subl_addr opprK ltW.
Qed.

Lemma eitv_infty_c r : `]-oo, r%:E]%classic =
  \bigcap_k `]-oo, (r%:E + k.+1%:R^-1%:E)]%classic :> set _.
Proof.
rewrite predeqE => x; split=> [|].
- move: x => [s /=|//|_ n _].
  + rewrite in_itv /= lee_fin => sr n _; rewrite /= in_itv /=.
    by rewrite -EFinD lee_fin (le_trans sr)// ler_addl invr_ge0.
  + by rewrite /= in_itv /= -EFinD lee_ninfty.
- move: x => [s|/(_ 0%N Logic.I)//|]/=; rewrite ?in_itv /= ?lee_ninfty//.
  move=> h; rewrite lee_fin leNgt; apply/negP => /ltr_add_invr[k rks].
  have {h} := h k Logic.I; rewrite /= in_itv /=.
  by rewrite -EFinD lee_fin leNgt => /negP; apply.
Qed.

Lemma eset1_ninfty :
  [set -oo] = \bigcap_k `]-oo, (-k%:R%:E)[%classic :> set (\bar R).
Proof.
rewrite eqEsubset; split=> [_ -> i _ |].
  by rewrite /= in_itv /= lte_ninfty.
move=> [r|/(_ O Logic.I)|]//.
move=> /(_ `|floor r|%N Logic.I); rewrite /= in_itv/= ltNge.
rewrite lee_fin; have [r0|r0] := leP 0%R r.
  by rewrite (le_trans _ r0) // ler_oppl oppr0 ler0n.
rewrite ler_oppl -abszN natr_absz gtr0_norm; last first.
  by rewrite ltr_oppr oppr0 floor_lt0.
by rewrite mulrNz ler_oppl opprK floor_le.
Qed.

Lemma eset1_pinfty :
  [set +oo] = \bigcap_k `]k%:R%:E, +oo[%classic :> set (\bar R).
Proof.
rewrite eqEsubset; split=> [_ -> i _/=|]; first by rewrite in_itv /= lte_pinfty.
move=> [r| |/(_ O Logic.I)] // /(_ `|ceil r|%N Logic.I); rewrite /= in_itv /=.
rewrite andbT lte_fin ltNge.
have [r0|r0] := ltP 0%R r; last by rewrite (le_trans r0).
by rewrite natr_absz gtr0_norm // ?ceil_ge// ceil_gt0.
Qed.

End erealwithrays.

Module ErealGenOInfty.
Section erealgenoinfty.
Variable R : realType.
Implicit Types (x y z : \bar R) (r s : R).

Local Open Scope ereal_scope.

Definition G := [set A : set \bar R | exists x, A = `]x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_set1_ninfty : @measurable T [set -oo].
Proof.
rewrite eset1_ninfty; apply: (@measurable_bigcap T) => i.
rewrite -set_itvC_bnd_infty; apply: measurableC; rewrite eitv_c_infty.
apply: measurable_bigcap => j; apply: g_salgebra_self.
by exists (- (i%:R + j.+1%:R^-1))%:E; rewrite opprD.
Qed.

Lemma measurable_set1_pinfty : @measurable T [set +oo].
Proof.
rewrite eset1_pinfty; apply: measurable_bigcap => i.
by apply: g_salgebra_self; exists i%:R%:E.
Qed.

Lemma measurableE : emeasurable (measurable : set (set (itvs R))) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  elim => [_ [x ->] | | |]; [|exact: emeasurable0| |].
  - rewrite /emeasurable /=; move: x => [r| |].
    + exists `]r, +oo[%classic.
        rewrite RGenOInfty.measurableE.
        exact: RGenOInfty.measurable_itv_bnd_infty.
      by exists [set +oo]; [constructor|rewrite -punct_eitv_bnd_pinfty].
    + exists set0 => //.
      by exists set0; [constructor|rewrite setU0 itv_opinfty_pinfty image_set0].
    + exists setT => //; exists [set +oo]; first by constructor.
      by rewrite itv_oninfty_pinfty punct_eitv_setTR.
  - by move=> *; rewrite setTD; exact: emeasurableC.
  - by move=> *; exact: emeasurable_bigcup.
move=> [B mB [C mC]] <-; apply: measurableU; last first.
  case: mC; [by []|exact: measurable_set1_ninfty
                  |exact: measurable_set1_pinfty|].
  - by apply: measurableU; [exact: measurable_set1_ninfty|
                            exact: measurable_set1_pinfty].
rewrite RGenOInfty.measurableE in mB.
elim: mB => [_ /= [r ->]| |D sD mD|F sF mF].
- rewrite EFin_itv_bnd_infty; apply: measurableD.
    by apply g_salgebra_self => /=; exists r%:E.
  exact: measurable_set1_pinfty.
- by rewrite image_set0.
- rewrite setTD setC_EFin; apply: measurableD; first exact: measurableC.
  by apply: measurableU; [exact: measurable_set1_ninfty|
                          exact: measurable_set1_pinfty].
- by rewrite bigcup_EFIn; apply: measurable_bigcup => i; exact: mF.
Qed.

End erealgenoinfty.
End ErealGenOInfty.

Module ErealGenCInfty.
Section erealgencinfty.
Variable R : realType.
Implicit Types (x y z : \bar R) (r s : R).
Local Open Scope ereal_scope.

Definition G := [set A : set \bar R | exists x, A = `[x, +oo[%classic].
Let T := g_measurableType G.

Lemma measurable_set1_ninfty : @measurable T [set -oo].
Proof.
rewrite eset1_ninfty; apply: measurable_bigcap=> i; rewrite -set_itvC_bnd_infty.
by apply: measurableC; apply: g_salgebra_self; exists (- i%:R)%:E.
Qed.

Lemma measurable_set1_pinfty : @measurable T [set +oo].
Proof.
apply: g_salgebra_self; exists +oo; rewrite predeqE => x; split => [->//|/=].
by rewrite in_itv /= andbT lee_pinfty_eq => /eqP ->.
Qed.

Lemma measurableE : emeasurable (measurable : set (set (itvs R))) = @measurable T.
Proof.
rewrite eqEsubset; split => A; last first.
  elim => [_ [x ->]| | |]; [|exact: emeasurable0| |].
  - rewrite /emeasurable /=; move: x => [r| |].
    + exists `[r, +oo[%classic.
        rewrite RGenOInfty.measurableE.
        exact: RGenOInfty.measurable_itv_bnd_infty.
      by exists [set +oo]; [constructor | rewrite -punct_eitv_bnd_pinfty].
    + exists set0 => //; exists [set +oo]; first by constructor.
      by rewrite image_set0 set0U itv_cpinfty_pinfty.
    + exists setT => //; exists [set -oo; +oo]; first by constructor.
      by rewrite itv_cninfty_pinfty setUA punct_eitv_setTL setUCl.
    + by move=> *; rewrite setTD; exact: emeasurableC.
    + by move=> *; exact: emeasurable_bigcup.
move=> [A' mA' [C mC]] <-; apply: measurableU; last first.
  case: mC; [by []|exact: measurable_set1_ninfty|
                   exact: measurable_set1_pinfty|].
  by apply: measurableU; [exact: measurable_set1_ninfty|
                          exact: measurable_set1_pinfty].
rewrite RGenCInfty.measurableE in mA'.
elim: mA' => [_ /= [r ->]| |B sB mB|F sF mF].
- rewrite EFin_itv_bnd_infty; apply: measurableD.
    by apply g_salgebra_self => /=; exists r%:E.
  exact: measurable_set1_pinfty.
- by rewrite image_set0.
- rewrite setTD setC_EFin; apply: measurableD; first exact: measurableC.
  by apply: measurableU; [exact: measurable_set1_ninfty|
                          exact: measurable_set1_pinfty].
- by rewrite bigcup_EFIn; apply: measurable_bigcup => i; exact: mF.
Qed.

End erealgencinfty.
End ErealGenCInfty.

(* NB: PR 435 in progress *)
From mathcomp Require Import rat.

Definition pair_of_rat (q : rat) : nat * nat :=
  let x := numq q in let y := denq q in
  (if x >= 0 then `|x|.*2 else `|x|.*2.+1, `|y|.-1).

Lemma pair_of_rat_inj : {in setT &, injective pair_of_rat}.
Proof.
move=> x y _ _; rewrite /pair_of_rat.
have [x_ge0|x_gt0] := leP 0 (numq x); have [y_ge0|y_gt0] := leP 0 (numq y).
- case=> /eqP; rewrite -!muln2 eqn_mul2r => /eqP/(congr1 Posz).
  rewrite !gez0_abs// => numqxy /(congr1 S); rewrite ?(prednK,absz_gt0)//.
  move=> /(congr1 Posz); rewrite 2!absz_denq => dxy; apply/eqP.
  by rewrite rat_eqE numqxy dxy 2!eqxx.
- by case=> /(congr1 odd); rewrite /= 2!odd_double.
- by case=> /(congr1 odd); rewrite /= 2!odd_double.
- case=> /eqP; rewrite -!muln2 eqn_mul2r => /eqP/(congr1 Posz).
  rewrite !ltz0_abs// => /eqP; rewrite eqr_opp => /eqP numqxy /(congr1 S).
  rewrite ?(prednK,absz_gt0)// => /(congr1 Posz); rewrite 2!absz_denq => dxy.
  by apply/eqP; rewrite rat_eqE numqxy dxy 2!eqxx.
Qed.

(* TODO: move to measure.v once PR 435 is merged *)
Lemma measurable_bigcup_rat (T : measurableType) (F : rat -> set T) :
  (forall i, measurable (F i)) -> measurable (\bigcup_i F i).
Proof.
move=> mF; have /card_esym/ppcard_eqP[f] := card_rat.
rewrite [X in measurable X](_ : _ = \bigcup_i F (f i)); last first.
  rewrite predeqE => r; split => [[q _ Fqr]|[n _ Fnr]];
  by [exists (f^-1%FUN q); rewrite //= invK ?inE | exists (f n)].
by apply: measurable_bigcup => i; exact/mF.
Qed.

Section trace.
Variable (T : Type).
Implicit Types (G : set (set T)) (A D : set T).

(* intended as a trace sigma-algebra *)
Definition strace G D := [set x `&` D | x in G].

Lemma stracexx G D : G D -> strace G D D.
Proof. by rewrite /strace /=; exists D => //; rewrite setIid. Qed.

Lemma are_measurable_sets_strace G D :
  are_measurable_sets setT G -> are_measurable_sets D (strace G D).
Proof.
move=> [G0 GC GU]; split; first by exists set0 => //; rewrite set0I.
- move=> S [A mA ADS]; have mCA := GC _ mA.
  have : strace G D (D `&` ~` A).
    by rewrite setIC; exists (setT `\` A) => //; rewrite setTD.
  rewrite -setDE => trDA.
  have DADS : D `\` A = D `\` S by rewrite -ADS !setDE setCI setIUr setICr setU0.
  by rewrite DADS in trDA.
- move=> S mS; have /choice[M GM] : forall n, exists A, G A /\ S n = A `&` D.
    by move=> n; have [A mA ADSn] := mS n; exists A.
  exists (\bigcup_i (M i)); first by apply GU => i;  exact: (GM i).1.
  by rewrite setI_bigcupl; apply eq_bigcupr => i _; rewrite (GM i).2.
Qed.

End trace.

(* TODO: PR limit inferior and limit superior *)
Section sdrop.
Variable R : realFieldType.
Implicit Types (r : R) (u : R^o^nat).

Definition sdrop T (u : T^nat) n := [set u k | k in [set k | k >= n]]%N.

Lemma has_lbound_sdrop u : has_lbound [set of u] ->
  forall m, has_lbound (sdrop u m).
Proof.
by move=> [M uM] n; exists M => _ [m /= nm] <-; rewrite uM //; exists m.
Qed.

Lemma has_ubound_sdrop u : has_ubound [set of u] ->
  (forall m, has_ubound (sdrop u m)).
Proof.
by move=> [M uM] n; exists M => _ [m /= nm] <-; rewrite uM //; exists m.
Qed.

End sdrop.

Section sups_infs.
Variable R : realType.
Implicit Types (r : R) (u : R^o^nat).

Definition sups u := [sequence sup (sdrop u n)]_n.

Definition infs u := [sequence inf (sdrop u n)]_n.

Lemma supsN u : sups (-%R \o u) = - infs u.
Proof.
rewrite funeqE => n; rewrite /sups /infs /inf /= opprK; congr (sup _).
by rewrite predeqE => x; split => [[m /= nm <-]|[_ [m /= nm] <-] <-];
  [exists (u m) => //; exists m | exists m].
Qed.

Lemma infsN u : infs (-%R \o u) = - sups u.
Proof.
apply/eqP; rewrite -eqr_oppLR -supsN; apply/eqP; congr (sups _).
by rewrite funeqE => ? /=; rewrite opprK.
Qed.

Lemma nonincreasing_sups u : has_ubound [set of u] ->
  nonincreasing_seq (sups u).
Proof.
move=> u_ub m n mn; apply: le_sup => [_ /= [p np] <-| |].
- by apply/downP; exists (u p) => //=; exists p => //; exact: leq_trans np.
- by exists (u n) => /=; exists n => /=.
- by split; [exists (u m); exists m => //=|exact/has_ubound_sdrop].
Qed.

Lemma nondecreasing_infs u : has_lbound [set of u] ->
  nondecreasing_seq (infs u).
Proof.
move=> u_lb; rewrite -nonincreasing_opp -supsN; apply/nonincreasing_sups.
by move: u_lb => /has_lb_ubN; rewrite /comp /= image_comp.
Qed.

Lemma is_cvg_sups u : cvg u -> cvg (sups u).
Proof.
move=> cf; have [M [Mreal Mu]] := cvg_seq_bounded cf.
apply: nonincreasing_is_cvg.
  exact/nonincreasing_sups/bounded_fun_has_ubound/cvg_seq_bounded.
exists (- (M + 1)) => _ [n _ <-]; rewrite (@le_trans _ _ (u n)) //.
  by apply/lerNnormlW/Mu => //; rewrite ltr_addl.
apply: sup_ub; last by exists n => /=.
exact/has_ubound_sdrop/bounded_fun_has_ubound/cvg_seq_bounded.
Qed.

Lemma is_cvg_infs u : cvg u -> cvg (infs u).
Proof.
move/is_cvgN/is_cvg_sups; rewrite supsN.
by move/(@is_cvgN _ [normedModType R of R^o]); rewrite opprK.
Qed.

Lemma infs_le_sups u n : cvg u -> infs u n <= sups u n.
Proof.
move=> cu; rewrite /infs /sups /=; set A := sdrop _ _.
have [a Aa] : A !=set0 by exists (u n); rewrite /A /=; exists n => //=.
rewrite (@le_trans _ _ a) //; [apply/inf_lb|apply/sup_ub] => //.
- exact/has_lbound_sdrop/bounded_fun_has_lbound/cvg_seq_bounded.
- exact/has_ubound_sdrop/bounded_fun_has_ubound/cvg_seq_bounded.
Qed.

Lemma cvg_sups_inf u : has_ubound [set of u] -> has_lbound [set of u] ->
  sups u --> inf [set of sups u].
Proof.
move=> u_ub u_lb.
apply: nonincreasing_cvg; first exact: nonincreasing_sups.
case: u_lb => M uM; exists M => _ [n _ <-].
rewrite (@le_trans _ _ (u n)) //; first by apply uM; exists n.
by apply: sup_ub; [exact/has_ubound_sdrop|exists n => /=].
Qed.

Lemma cvg_infs_sup u : has_ubound [set of u] -> has_lbound [set of u] ->
  infs u --> sup [set of infs u].
Proof.
move=> u_ub u_lb; have : sups (- u) --> inf [set of sups (- u)].
  apply: cvg_sups_inf.
  - by move: u_lb => /has_lb_ubN; rewrite image_comp.
  - by move: u_ub => /has_ub_lbN; rewrite image_comp.
rewrite /inf => /(@cvg_comp _ _ _ _ (fun x => - x)).
rewrite supsN /comp /= -[in X in _ -> X --> _](opprK (infs u)); apply.
rewrite image_comp /comp /= -(opprK (sup [set of infs u])).
apply: (@cvgN _ [normedModType R of R^o]).
by rewrite (_ : [set _ | _ in setT] = [set of infs u]) // opprK.
Qed.

Lemma sups_preimage T (D : set T) r (f : (T -> R)^nat) n :
  (forall t, D t -> has_ubound [set of f ^~ t]) ->
  D `&` (fun x => sups (f ^~x) n) @^-1` `]r, +oo[%classic =
  D `&` \bigcup_(k in [set k | n <= k]%N) f k @^-1` `]r, +oo[.
Proof.
move=> f_ub; rewrite predeqE => t; split.
- have [|/set0P h] := eqVneq (sdrop (f ^~ t) n) set0.
    by rewrite predeqE => /(_ (f n t))[+ _] => /forall2NP/(_ n)/= [].
  rewrite /= preimage_itv in_itv /= andbT => -[Dt].
  move=> /(sup_gt h)[_ [m /= nm <-]] rfmt. split => //; exists m => //.
  by rewrite preimage_itv in_itv /= rfmt.
- move=> [Dt [k /= nk]]; rewrite preimage_itv in_itv /= andbT => rfkt.
  split=> //; rewrite preimage_itv in_itv /= andbT; apply: (lt_le_trans rfkt).
  by apply: sup_ub; [exact/has_ubound_sdrop/f_ub|by exists k].
Qed.

Lemma infs_preimage T (D : set T) r (f : (T -> R)^nat) n :
  (forall t, D t -> has_lbound [set of f ^~ t]) ->
  D `&` (fun x => infs (f ^~ x) n) @^-1` `]-oo, r[ =
  D `&` \bigcup_(k in [set k | n <= k]%N) f k @^-1` `]-oo, r[.
Proof.
move=> lb_f; rewrite predeqE => t; split.
- have [|/set0P h] := eqVneq (sdrop (f ^~ t) n) set0.
    by rewrite predeqE => /(_ (f n t))[+ _] => /forall2NP/(_ n)/= [].
  rewrite /= preimage_itv in_itv /= => -[Dt].
  by move=>  /(inf_lt h)[_ [m /= nm <-]] fmtr; split => //; exists m.
- move=> [Dt [k /= nk]]; rewrite preimage_itv in_itv /= => fktr.
  rewrite preimage_itv in_itv /=; split => //; apply: le_lt_trans fktr.
  by apply/inf_lb => //; [exact/has_lbound_sdrop/lb_f|by exists k].
Qed.

Lemma bounded_fun_has_lbound_sups u :
  bounded_fun u -> has_lbound [set of sups u].
Proof.
move=> /[dup] ba /bounded_fun_has_lbound/has_lbound_sdrop h.
have [M hM] := h O; exists M => y [n _ <-].
rewrite (@le_trans _ _ (u n)) //; first by apply hM; exists n.
apply: sup_ub; last by exists n => /=.
by move: ba => /bounded_fun_has_ubound/has_ubound_sdrop; exact.
Qed.

Lemma bounded_fun_has_ubound_infs u :
  bounded_fun u -> has_ubound [set of infs u].
Proof.
move=> /[dup] ba /bounded_fun_has_ubound/has_ubound_sdrop h.
have [M hM] := h O; exists M => y [n _ <-].
rewrite (@le_trans _ _ (u n)) //; last by apply hM; exists n.
apply: inf_lb; last by exists n => /=.
by move: ba => /bounded_fun_has_lbound/has_lbound_sdrop; exact.
Qed.

End sups_infs.

Section lim_sup_lim_inf.
Variable R : realType.
Implicit Types (r : R) (u v : R^o^nat).

Definition lim_sup u := lim (sups u).

Definition lim_inf u := lim (infs u).

Lemma lim_infN u : cvg u -> lim_inf (-%R \o u) = - lim_sup u.
Proof.
move=> cu_; rewrite /lim_inf infsN.
rewrite (@limN _ [normedModType R of R^o] _ _ _ (sups u)) //.
exact: is_cvg_sups.
Qed.

Lemma lim_supE u : bounded_fun u -> lim_sup u = inf [set of sups u].
Proof.
move=> ba; apply/cvg_lim; first exact: Rhausdorff.
by apply/cvg_sups_inf; [exact/bounded_fun_has_ubound|
                        exact/bounded_fun_has_lbound].
Qed.

Lemma lim_infE u : bounded_fun u -> lim_inf u = sup [set of infs u].
Proof.
move=> ba; apply/cvg_lim; first exact: Rhausdorff.
apply/cvg_infs_sup; [exact/bounded_fun_has_ubound|
                     exact/bounded_fun_has_lbound].
Qed.

Lemma lim_inf_le_lim_sup u : cvg u -> lim_inf u <= lim_sup u.
Proof.
move=> cf_; apply: ler_lim; [exact: is_cvg_infs|exact: is_cvg_sups|].
by apply: nearW => n; apply: infs_le_sups.
Qed.

Lemma cvg_lim_inf_sup u l : u --> l -> (lim_inf u = l) * (lim_sup u = l).
Proof.
move=> ul.
have /cvg_seq_bounded [M [Mr Mu]] : cvg u by apply/cvg_ex; eexists; exact: ul.
suff: lim_sup u <= l <= lim_inf u.
  move=> /andP[sul liu].
  have /lim_inf_le_lim_sup iusu : cvg u by apply/cvg_ex; eexists; exact: ul.
  split; first by apply/eqP; rewrite eq_le liu andbT (le_trans iusu).
  by apply/eqP; rewrite eq_le sul /= (le_trans _ iusu).
apply/andP; split.
- apply/ler_addgt0Pr => e e0.
  apply: lim_le; first by apply: is_cvg_sups; apply/cvg_ex; exists l.
  move/cvg_distP : (ul) => /(_ _ e0); rewrite near_map => -[k _ klu].
  near=> n; have kn : (k <= n)%N by near: n; exists k.
  apply: sup_le_ub; first by exists (u n) => /=; exists n => //=.
  move=> _ /= [m nm] <-; apply/ltW/ltr_distl_addr; rewrite distrC.
  by apply: (klu m) => /=; rewrite (leq_trans kn).
- apply/ler_addgt0Pr => e e0; rewrite -ler_subl_addr.
  apply: lim_ge; first by apply: is_cvg_infs; apply/cvg_ex; exists l.
  move/cvg_distP : (ul) => /(_ _ e0); rewrite near_map => -[k _ klu].
  near=> n; have kn: (k <= n)%N by near: n; exists k.
  apply: lb_le_inf; first by exists (u n) => /=; exists n => //=.
  move=> _ /= [m nm] <-; apply/ltW/ltr_distl_subl.
  by apply: (klu m) => /=; rewrite (leq_trans kn).
Unshelve. all: by end_near. Qed.

Lemma cvg_lim_infE u : cvg u -> lim_inf u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [-> _] := cvg_lim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

Lemma cvg_lim_supE u : cvg u -> lim_sup u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [_ ->] := cvg_lim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

Lemma cvg_sups u l : u --> l -> (sups u) --> (l : R^o).
Proof.
move=> ul; have [iul <-] := cvg_lim_inf_sup ul.
have cu : cvg u by apply/cvg_ex; eexists; apply: ul.
have /cvg_ex[l' sul'] := is_cvg_sups cu.
by move/cvg_lim : (sul') ; rewrite /lim_sup => ->//; exact: Rhausdorff.
Qed.

Lemma cvg_infs u l : u --> l -> (infs u) --> (l : R^o).
Proof.
move=> ul; have [<- iul] := cvg_lim_inf_sup ul.
have cu : cvg u by apply/cvg_ex; eexists; apply: ul.
have /cvg_ex[l' sul'] := is_cvg_infs cu.
by move/cvg_lim : (sul') ; rewrite /lim_inf => ->//; exact: Rhausdorff.
Qed.

Lemma le_lim_supD u v :
  bounded_fun u -> bounded_fun v -> lim_sup (u \+ v) <= lim_sup u + lim_sup v.
Proof.
move=> ba bb; have ab k : sups (u \+ v) k <= sups u k + sups v k.
  apply: sup_le_ub; first by exists ((u \+ v) k); exists k => /=.
  by move=> M [n /= kn <-]; apply: ler_add; apply: sup_ub; [
    exact/has_ubound_sdrop/bounded_fun_has_ubound; exact | exists n |
    exact/has_ubound_sdrop/bounded_fun_has_ubound; exact | exists n ].
have cu : cvg (sups u).
  apply: nonincreasing_is_cvg; last exact: bounded_fun_has_lbound_sups.
  exact/nonincreasing_sups/bounded_fun_has_ubound.
have cv : cvg (sups v).
  apply: nonincreasing_is_cvg; last exact: bounded_fun_has_lbound_sups.
  exact/nonincreasing_sups/bounded_fun_has_ubound.
rewrite -(@limD _ [normedModType R of R^o] _ _ _ _ _ cu cv); apply: ler_lim.
- apply: nonincreasing_is_cvg; last first.
    exact/bounded_fun_has_lbound_sups/bounded_funD.
  exact/nonincreasing_sups/bounded_fun_has_ubound/bounded_funD.
- exact: (@is_cvgD _ [normedModType R of R^o] _ _ _ _ _ cu cv).
- exact: nearW.
Qed.

Lemma le_lim_infD u v :
  bounded_fun u -> bounded_fun v -> lim_inf u + lim_inf v <= lim_inf (u \+ v).
Proof.
move=> ba bb; have ab k : infs u k + infs v k <= infs (u \+ v) k.
  apply: lb_le_inf; first by exists ((u \+ v) k); exists k => /=.
  by move=> M [n /= kn <-]; apply: ler_add; apply: inf_lb; [
    exact/has_lbound_sdrop/bounded_fun_has_lbound; exact | exists n |
    exact/has_lbound_sdrop/bounded_fun_has_lbound; exact | exists n ].
have cu : cvg (infs u).
  apply: nondecreasing_is_cvg; last exact: bounded_fun_has_ubound_infs.
  exact/nondecreasing_infs/bounded_fun_has_lbound.
have cv : cvg (infs v).
  apply: nondecreasing_is_cvg; last exact: bounded_fun_has_ubound_infs.
  exact/nondecreasing_infs/bounded_fun_has_lbound.
rewrite -(@limD _ [normedModType R of R^o] _ _ _ _ _ cu cv); apply: ler_lim.
- exact: (@is_cvgD _ [normedModType R of R^o] _ _ _ _ _ cu cv).
- apply: nondecreasing_is_cvg; last first.
    exact/bounded_fun_has_ubound_infs/bounded_funD.
  exact/nondecreasing_infs/bounded_fun_has_lbound/bounded_funD.
- exact: nearW.
Qed.

Lemma lim_supD u v : cvg u -> cvg v -> lim_sup (u \+ v) = lim_sup u + lim_sup v.
Proof.
move=> cu cv; have [ba bb] := (cvg_seq_bounded cu, cvg_seq_bounded cv).
apply/eqP; rewrite eq_le le_lim_supD //=.
have := @le_lim_supD _ _ (bounded_funD ba bb) (bounded_funN bb).
rewrite -ler_subl_addr; apply: le_trans.
rewrite -[_ \+ _]/(u + v - v) addrK -lim_infN; last exact: is_cvgN.
rewrite /comp /=; under eq_fun do rewrite opprK.
by rewrite ler_add// cvg_lim_infE// cvg_lim_supE.
Qed.

Lemma lim_infD u v : cvg u -> cvg v -> lim_inf (u \+ v) = lim_inf u + lim_inf v.
Proof.
move=> cu cv; rewrite (cvg_lim_infE cu) -(cvg_lim_supE cu).
rewrite (cvg_lim_infE cv) -(cvg_lim_supE cv) -lim_supD//.
rewrite cvg_lim_supE; last exact: (@is_cvgD _ _ _ _ _ _ _ cu cv).
by rewrite cvg_lim_infE //; exact: (@is_cvgD _ _ _ _ _ _ _ cu cv).
Qed.

End lim_sup_lim_inf.

Section esups_einfs.
Variable R : realType.
Implicit Types (u : (\bar R)^nat).
Local Open Scope ereal_scope.

Definition esups u := [sequence ereal_sup (sdrop u n)]_n.

Definition einfs u := [sequence ereal_inf (sdrop u n)]_n.

Lemma esupsN u : esups (-%E \o u) = -%E \o einfs u.
Proof.
rewrite funeqE => n; rewrite /esups /= oppeK; congr (ereal_sup _).
by rewrite predeqE => x; split => [[m /= nm <-]|[_ [m /= nm] <-] <-];
  [exists (u m) => //; exists m | exists m].
Qed.

Lemma einfsN u : einfs (-%E \o u) = -%E \o esups u.
Proof.
by rewrite [in RHS](_ : u = -%E \o -%E \o u);
  rewrite ?esupsN funeqE => n /=; rewrite oppeK.
Qed.

Lemma nonincreasing_esups u : nonincreasing_seq (esups u).
Proof.
move=> m n mn; apply: le_ereal_sup => _ /= [k nk <-]; exists k => //=.
by rewrite (leq_trans mn).
Qed.

Lemma nondecreasing_einfs u : nondecreasing_seq (einfs u).
Proof.
move=> m n mn; apply: le_ereal_inf => _ /= [k nk <-]; exists k => //=.
by rewrite (leq_trans mn).
Qed.

Lemma einfs_le_esups u n : einfs u n <= esups u n.
Proof.
rewrite /einfs /=; set A := sdrop _ _; have [a Aa] : A !=set0.
  by exists (u n); rewrite /A /=; exists n => //=.
by rewrite (@le_trans _ _ a) //; [exact/ereal_inf_lb|exact/ereal_sup_ub].
Unshelve. all: by end_near. Qed.

Lemma cvg_esups_inf u : esups u --> ereal_inf [set of esups u].
Proof. by apply: ereal_nonincreasing_cvg => //; exact: nonincreasing_esups. Qed.

Lemma is_cvg_esups u : cvg (esups u).
Proof. by apply/cvg_ex; eexists; exact/cvg_esups_inf. Qed.

Lemma cvg_einfs_sup u : einfs u --> ereal_sup [set of einfs u].
Proof. by apply: ereal_nondecreasing_cvg => //; exact: nondecreasing_einfs. Qed.

Lemma is_cvg_einfs u : cvg (einfs u).
Proof. by apply/cvg_ex; eexists; exact/cvg_einfs_sup. Qed.

Lemma esups_preimage T (a : \bar R) (f : (T -> \bar R)^nat) n :
  (fun x => esups (f^~x) n) @^-1` `]a, +oo[ =
  \bigcup_(k in [set k | n <= k]%N) f k @^-1` `]a, +oo[.
Proof.
rewrite predeqE => t; split => /=.
  rewrite preimage_itv in_itv /= andbT=> /ereal_sup_gt[_ [/= k nk <-]] afnt.
  by exists k => //=; rewrite preimage_itv in_itv /= afnt.
move=> -[k /= nk] /=; rewrite preimage_itv in_itv /= andbT => /lt_le_trans afkt.
by rewrite preimage_itv in_itv andbT/=; apply/afkt/ereal_sup_ub; exists k.
Qed.

Lemma einfs_preimage T (a : \bar R) (f : (T -> \bar R)^nat) n :
  (fun x => einfs (f^~x) n) @^-1` `[a, +oo[%classic =
  \bigcap_(k in [set k | n <= k]%N) f k @^-1` `[a, +oo[%classic.
Proof.
rewrite predeqE => t; split => /= [|h].
  rewrite preimage_itv in_itv andbT /= => h k nk /=.
  by rewrite preimage_itv in_itv/= (le_trans h)//; apply ereal_inf_lb; exists k.
rewrite preimage_itv in_itv /= andbT leNgt; apply/negP.
move=> /ereal_inf_lt[_ /= [k nk <-]]; apply/negP.
by have := h _ nk; rewrite preimage_itv in_itv /= andbT -leNgt.
Qed.

End esups_einfs.

Section elim_sup_inf.
Local Open Scope ereal_scope.
Variable R : realType.
Implicit Types (u v : (\bar R)^nat) (l : \bar R).

Definition elim_sup u := lim (esups u).

Definition elim_inf u := lim (einfs u).

Lemma elim_infN u : elim_inf (-%E \o u) = - elim_sup u.
Proof.
by rewrite /elim_inf einfsN /elim_sup ereal_limN //; exact/is_cvg_esups.
Qed.

Lemma elim_supN u : elim_sup (-%E \o u) = - elim_inf u.
Proof.
apply/eqP; rewrite -eqe_oppLR -elim_infN /=.
by rewrite (_ : _ \o _ = u) // funeqE => n /=; rewrite oppeK.
Qed.

Lemma elim_inf_sup u : elim_inf u <= elim_sup u.
Proof.
apply: lee_lim; [exact/is_cvg_einfs|exact/is_cvg_esups|].
by apply: nearW; exact: einfs_le_esups.
Qed.

Lemma cvg_ninfty_elim_inf_sup u : u --> -oo ->
  (elim_inf u = -oo) * (elim_sup u = -oo).
Proof.
move=> unoo; suff: elim_sup u = -oo.
  move=> {}unoo; split => //; apply/eqP.
  by rewrite -lee_ninfty_eq -unoo elim_inf_sup.
apply/cvg_lim => //=; apply/ereal_cvgPninfty => M M0.
move: unoo => /ereal_cvgPninfty /(_ _ M0)[m _ h].
near=> n; apply ub_ereal_sup => _ [k /= nk] <-.
by apply h => /=; rewrite (leq_trans _ nk) //; near: n; exists m.
Unshelve. all: by end_near. Qed.

Lemma cvg_ninfty_einfs u : u --> -oo -> einfs u --> -oo.
Proof.
move=> /cvg_ninfty_elim_inf_sup[uoo _]; have /cvg_ex[l ul] := @is_cvg_einfs _ u.
by have <- : l = -oo by rewrite -uoo; apply/esym/cvg_lim.
Qed.

Lemma cvg_ninfty_esups u : u --> -oo -> esups u --> -oo.
Proof.
move=> /cvg_ninfty_elim_inf_sup[_ uoo]; have /cvg_ex[l ul] := @is_cvg_esups _ u.
by have <- : l = -oo by rewrite -uoo; apply/esym/cvg_lim.
Qed.

Lemma cvg_pinfty_einfs u : u --> +oo -> einfs u --> +oo.
Proof.
move=> /ereal_cvgN/cvg_ninfty_esups/ereal_cvgN; rewrite esupsN.
apply: cvg_trans; rewrite (_ : _ \o (_ \o _) = einfs u) //.
by rewrite funeqE => n /=; rewrite oppeK.
Qed.

Lemma cvg_pinfty_esups u : u --> +oo -> esups u --> +oo.
Proof.
move=> /ereal_cvgN/cvg_ninfty_einfs/ereal_cvgN; rewrite einfsN.
apply: cvg_trans; rewrite (_ : _ \o (_ \o _) = esups u) //.
by rewrite funeqE => n /=; rewrite oppeK.
Qed.

Lemma cvg_esups u l : u --> l -> esups u --> l.
Proof.
case: l => [l /ereal_cvg_real[u_fin_num] ul| |]; last 2 first.
  - exact: cvg_pinfty_esups.
  - exact: cvg_ninfty_esups.
have [p _ pu] := u_fin_num; apply/cvg_ballP => _/posnumP[e].
have : EFin \o sups (fine \o u) --> l%:E.
  by apply: continuous_cvg => //; apply: cvg_sups.
move=> /cvg_ballP /(_ e%:num (posnum_gt0 _))[q _ qsupsu].
rewrite near_simpl; near=> n.
have -> : esups u n = (EFin \o sups (fine \o u)) n.
  rewrite /= -ereal_sup_EFin; last 2 first.
    - apply/has_ubound_sdrop/bounded_fun_has_ubound.
      apply/(@cvg_seq_bounded _ [normedModType R of R^o])/cvg_ex.
      by eexists; exact ul.
    - by eexists; rewrite /sdrop /=; exists n; [|reflexivity].
  congr (ereal_sup _).
  rewrite predeqE => y; split=> [[m /= nm <-{y}]|[r [m /= nm <-{r} <-{y}]]].
    have /pu : (p <= m)%N by rewrite (leq_trans _ nm) //; near: n; exists p.
    by move=> /fineK umE; eexists; [exists m|exact/umE].
  have /pu : (p <= m)%N by rewrite (leq_trans _ nm) //; near: n; exists p.
  by move=> /fineK umE; exists m => //; exact/umE.
by apply: qsupsu => /=; near: n; exists q.
Unshelve. all: by end_near. Qed.

Lemma cvg_einfs u l : u --> l -> einfs u --> l.
Proof.
move=> /ereal_cvgN/cvg_esups/ereal_cvgN; rewrite oppeK esupsN.
by rewrite (_ : _ \o (_ \o _) = einfs u) // funeqE => n /=; rewrite oppeK.
Qed.

Lemma cvg_elim_inf_sup u l : u --> l -> (elim_inf u = l) * (elim_sup u = l).
Proof.
by move=> ul; split; apply/cvg_lim => //; [apply/cvg_einfs|apply/cvg_esups].
Qed.

Lemma is_cvg_elim_infE u : cvg u -> elim_inf u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [-> _] := cvg_elim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

Lemma is_cvg_elim_supE u : cvg u -> elim_sup u = lim u.
Proof.
move=> /cvg_ex[l ul]; have [_ ->] := cvg_elim_inf_sup ul.
by move/cvg_lim : ul => ->.
Qed.

End elim_sup_inf.

(* TODO: PR the properties of measurable functions to measure.v *)
Section measurable_fun.
Implicit Types T : measurableType.

Lemma measurable_fun_id T (D : set T) : measurable_fun D id.
Proof. by move=> mD A mA; apply: measurableI. Qed.

Lemma measurable_fun_comp T1 T2 T3 (f : T2 -> T3) E (g : T1 -> T2) :
  measurable_fun setT f -> measurable_fun E g -> measurable_fun E (f \o g).
Proof.
move=> mf mg /= mE A mA; rewrite comp_preimage; apply/mg => //.
by rewrite -[X in measurable X]setTI; apply/mf.
Qed.

Lemma eq_measurable_fun T1 T2 (D : set T1) (f g : T1 -> T2) :
  {in D, f =1 g} -> measurable_fun D f -> measurable_fun D g.
Proof.
move=> Dfg Df mD A mA; rewrite (_ : D `&` _ = D `&` f @^-1` A); first exact: Df.
apply/seteqP; rewrite /preimage; split => [x /= [Dx Agx]|x /= [Dx Afx]].
  by split=> //; rewrite Dfg// inE.
by split=> //; rewrite -Dfg// inE.
Qed.

Lemma measurable_fun_cst T1 T2 (D : set T1) (r : T2) :
  measurable_fun D (cst r : T1 -> _).
Proof.
move=> mD A mA; have [rA|rA] := boolP (r \in A).
- rewrite [X in measurable X](_ : _ = D) // predeqE => t; split=> [[]//|Dt].
  by split => //; rewrite inE in rA.
- rewrite [X in measurable X](_ : _ = set0)// predeqE.
  by move=> t; split=> // -[]; rewrite notin_set in rA.
Qed.

Lemma measurable_funU T1 T2 (D E : set T1) (f : T1 -> T2) :
  measurable D -> measurable E ->
  measurable_fun (D `|` E) f <-> measurable_fun D f /\ measurable_fun E f.
Proof.
move=> mD mE; split=> [mDEf|[mDf mEf] mDE A mA]; last first.
  by rewrite setIUl; apply: measurableU; [exact: mDf|exact: mEf].
split.
- move=> {}mD A /mDEf => /(_ (measurableU _ _ mD mE))/(measurableI D)-/(_ mD).
  by rewrite setICA setIA setUK.
- move=> {}mE A /mDEf => /(_ (measurableU _ _ mD mE))/(measurableI E)-/(_ mE).
 by rewrite setICA setIA setUC setUK.
Qed.

Lemma measurable_funS T1 T2 (E D : set T1) (f : T1 -> T2) :
     measurable E -> D `<=` E -> measurable_fun E f ->
  measurable_fun D f.
Proof.
move=> mE DE mf mD; have mC : measurable (E `\` D) by exact: measurableD.
move: (mD).
have := measurable_funU f mD mC.
suff -> : (D `|` (E `\` D)) = E by move=> [[]] //.
by rewrite setDUK.
Qed.

End measurable_fun.

Section standard_measurable_fun.

Lemma measurable_fun_normr (R : realType) (D : set R) :
  measurable_fun D (@normr _ R).
Proof.
move=> mD; apply: (measurability (RGenOInfty.measurableE R)) => //.
move=> /= _ [_ [x ->] <-]; apply: measurableI => //.
have [x0|x0] := leP 0 x.
  rewrite [X in measurable X](_ : _ = `]-oo, (- x)[ `|` `]x, +oo[)%classic.
    by apply: measurableU; exact/measurable_itv.
  rewrite predeqE => r; split => [|[|]]; rewrite preimage_itv in_itv andbT/=.
  - have [r0|r0] := leP 0 r; [rewrite ger0_norm|rewrite ltr0_norm] => // xr;
      rewrite 2!in_itv/=.
    + by right; rewrite xr.
    + by left; rewrite ltr_oppr.
  - move=> rx /=.
    by rewrite ler0_norm 1?ltr_oppr// (le_trans (ltW rx))// ler_oppl oppr0.
  - by rewrite in_itv /= andbT => xr; rewrite (lt_le_trans _ (ler_norm _)).
rewrite [X in measurable X](_ : _ = setT)// predeqE => r.
by split => // _; rewrite preimage_itv in_itv /= andbT (lt_le_trans x0).
Qed.

End standard_measurable_fun.

Section measurable_fun_realType.
Variables (T : measurableType) (R : realType).
Implicit Types (D : set T) (f g : T -> R).

Lemma measurable_funD D f g :
  measurable_fun D f -> measurable_fun D g -> measurable_fun D (f \+ g).
Proof.
move=> mf mg mD; apply: (measurability (RGenOInfty.measurableE R)) => //.
move=> /= _ [_ [a ->] <-]; rewrite preimage_itv_o_infty.
rewrite [X in measurable X](_ : _ = \bigcup_(r : rat)
  ((D `&` [set x | ratr r < f x]) `&` (D `&` [set x | a - ratr r < g x]))).
  apply: measurable_bigcup_rat => q; apply: measurableI.
  - by rewrite -preimage_itv_o_infty; exact/mf/measurable_itv.
  - by rewrite -preimage_itv_o_infty; exact/mg/measurable_itv.
rewrite predeqE => x; split => [|[r _] []/= [Dx rfx]] /= => [[Dx]|[_]].
  rewrite -ltr_subl_addr => /rat_in_itvoo[r]; rewrite inE /= => /itvP h.
  exists r => //; rewrite setIACA setIid; split => //; split => /=.
    by rewrite h.
  by rewrite ltr_subl_addr addrC -ltr_subl_addr h.
by rewrite ltr_subl_addr=> afg; rewrite (lt_le_trans afg)// addrC ler_add2r ltW.
Qed.

Lemma measurable_fun_sqr D f :
  measurable_fun D f -> measurable_fun D (fun x => f x ^+ 2).
Proof.
move=> mf /= A mA mD.
apply: (measurability (RGenOInfty.measurableE R)) => //= _ [_ [a ->] <-].
have [a0|a0] := leP 0 a; last first.
  rewrite (_ : _ `&` _ = D) // predeqE => x; split => [[]//|Dx]; split => //.
  by rewrite preimage_itv in_itv /= andbT (lt_le_trans a0)// sqr_ge0.
rewrite (_ : D `&` _ = (D `&` f @^-1` `]Num.sqrt a, +oo[) `|`
                       (D `&` f @^-1` `]-oo, -Num.sqrt a[) ).
  by apply: measurableU; exact/mf/measurable_itv.
rewrite predeqE => t; split=> [[]|].
  rewrite preimage_itv in_itv /= andbT => Dt aft2.
  have := le_lt_trans a0 aft2.
  rewrite exprn_even_gt0 //= neq_lt => /orP[|] ft0.
    move: aft2; rewrite -ltr_sqrt; last first.
      by rewrite exprn_even_gt0//= lt_eqF.
    by rewrite sqrtr_sqr ltr0_norm// ltr_oppr; tauto.
  move: aft2; rewrite -ltr_sqrt; last first.
    by rewrite exprn_even_gt0//= gt_eqF.
  by rewrite sqrtr_sqr gtr0_norm// !preimage_itv !in_itv/= andbT; tauto.
move=> [] /=; rewrite !preimage_itv !in_itv /= ?andbT => -[Dt fta]; split => //.
  rewrite -ltr_sqrt; last first.
    by rewrite exprn_even_gt0//= gt_eqF// (le_lt_trans _ fta)// sqrtr_ge0.
  by rewrite sqrtr_sqr gtr0_norm// (le_lt_trans _ fta)// sqrtr_ge0.
rewrite -ltr_sqrt; last first.
  rewrite exprn_even_gt0//= lt_eqF// (lt_le_trans fta)// -ler_oppl oppr0.
  by rewrite sqrtr_ge0.
rewrite sqrtr_sqr ltr0_norm// 1?ltr_oppr//.
by rewrite (lt_le_trans fta)// -ler_oppl oppr0 sqrtr_ge0.
Qed.

Lemma measurable_funrM D f (k : R) : measurable_fun D f ->
  measurable_fun D (fun x => k * f x).
Proof.
have [-> _|] := eqVneq k 0.
  rewrite (_ : (fun _ => _) = cst 0); first exact: measurable_fun_cst.
  by rewrite funeqE// => t; rewrite mul0r.
rewrite neq_lt => /orP[k0|k0] mf mD;
  apply: (measurability (RGenOInfty.measurableE R)) => //= A [B [a ->] <-].
- rewrite preimage_itv_o_infty [X in measurable X](_ : _ =
      D `&` f @^-1` `]-oo, a / k[); last first.
    rewrite predeqE => t; split => [[/= akft Dtr]|[]].
      by rewrite preimage_itv in_itv/= ltr_ndivl_mulr// mulrC.
    by rewrite preimage_itv in_itv /= => Dt ftak; rewrite mulrC -ltr_ndivl_mulr.
  by apply: mf =>//; rewrite -(set_itv_infty_o (a / k)); exact/measurable_itv.
- rewrite preimage_itv_o_infty [X in measurable X](_ : _ =
      D `&` f @^-1` `]a / k, +oo[); first exact/mf/measurable_itv.
  rewrite predeqE => t; split => [[/= Dt akft]|[Dr]].
    by rewrite preimage_itv in_itv/= andbT ltr_pdivr_mulr// mulrC.
  by rewrite preimage_itv in_itv/= andbT => akft; rewrite mulrC -ltr_pdivr_mulr.
Qed.

Lemma measurable_funN D f : measurable_fun D f -> measurable_fun D (-%R \o f).
Proof.
move=> mf mD; rewrite (_ : _ \o _ = (fun x => - 1 * f x)).
  exact: measurable_funrM.
by under eq_fun do rewrite mulN1r.
Qed.

Lemma measurable_funB D f g : measurable_fun D f ->
  measurable_fun D g -> measurable_fun D (f \- g).
Proof.
by move=> ? ? ?; apply: measurable_funD => //; exact: measurable_funN.
Qed.

Lemma measurable_funM D f g :
  measurable_fun D f -> measurable_fun D g ->
  measurable_fun D (fun x => f x * g x).
Proof.
move=> mf mg mD.
rewrite (_ : (fun _ => _) = (fun x => 2%:R^-1 * (f x + g x) ^+ 2)
  \- (fun x => 2%:R^-1 * (f x ^+ 2)) \- (fun x => 2%:R^-1 * ( g x ^+ 2))).
  apply: measurable_funB => //; last first.
    by apply: measurable_funrM => //; exact: measurable_fun_sqr.
  apply: measurable_funB => //; last first.
    by apply: measurable_funrM => //; exact: measurable_fun_sqr.
  apply: measurable_funrM => //.
  by apply: measurable_fun_sqr => //; exact: measurable_funD.
rewrite funeqE => x /=; rewrite -2!mulrBr sqrrD (addrC (f x ^+ 2)) -addrA.
rewrite -(addrA (f x * g x *+ 2)) -opprB opprK (addrC (g x ^+ 2)) addrK.
by rewrite -(mulr_natr (f x * g x)) -(mulrC 2) mulrA mulVr ?mul1r// unitfE.
Qed.

Lemma measurable_fun_sup D (h : (T -> R)^nat) n :
  (forall t, D t -> has_ubound [set of h^~t]) ->
  (forall m, measurable_fun D (h m)) ->
  measurable_fun D (fun x => sup (sdrop (h^~x) n)).
Proof.
move=> f_ub mf mD; apply: (measurability (RGenOInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite sups_preimage // setI_bigcupr.
by apply: bigcup_measurable => k /= nk; exact/mf/measurable_itv.
Qed.

Lemma measurable_fun_inf D (h : (T -> R)^nat) n :
  (forall t, D t -> has_lbound [set of h ^~ t]) ->
  (forall n, measurable_fun D (h n)) ->
  measurable_fun D (fun x => inf (sdrop (h ^~ x) n)).
Proof.
move=> lb_f mf mD; apply: (measurability (RGenInftyO.measurableE R)) =>//.
move=> _ [_ [x ->] <-]; rewrite infs_preimage // setI_bigcupr.
by apply: bigcup_measurable => k /= nk; exact/mf/measurable_itv.
Qed.

Lemma measurable_fun_lim_sup D (h : (T -> R)^nat) :
  (forall t, D t -> has_ubound [set of h^~t]) ->
  (forall t, D t -> has_lbound [set of h^~t]) ->
  (forall n, measurable_fun D (h n)) ->
  measurable_fun D (fun x => lim_sup (h ^~ x)).
Proof.
move=> f_ub f_lb mf.
have : {in D, (fun x => inf [set sups (h ^~ x) n | n in [set n | 0 <= n]%N])
              =1 (fun x => lim_sup (h^~ x))}.
  move=> t; rewrite inE => Dt; apply/esym/cvg_lim; first exact: Rhausdorff.
  rewrite [X in _ --> X](_ : _ = inf [set of sups (h^~t)]).
    by apply: cvg_sups_inf; [exact: f_ub|exact: f_lb].
  by congr (inf [set _ | _ in _]); rewrite predeqE.
move/eq_measurable_fun; apply; apply: measurable_fun_inf => //.
  move=> t Dt; have [M hM] := f_lb _ Dt; exists M => _ [m /= nm <-].
  rewrite (@le_trans _ _ (h m t)) //; first by apply hM => /=; exists m.
  by apply: sup_ub; [exact/has_ubound_sdrop/f_ub|exists m => /=].
by move=> k; exact: measurable_fun_sup.
Qed.

Lemma measurable_fun_cvg D (h : (T -> R)^nat) f :
  (forall m, measurable_fun D (h m)) -> (forall x, D x -> h ^~ x --> f x) ->
  measurable_fun D f.
Proof.
move=> mf_ f_f; have fE x : D x -> f x = lim_sup (h ^~ x).
  move=> Dx; have /cvg_lim  <-// := (@cvg_sups _ (h ^~ x) (f x) (f_f _ Dx)).
  exact: Rhausdorff.
apply: (@eq_measurable_fun _ _ D (fun x => lim_sup (h ^~ x))).
  by move=> x; rewrite inE => Dx; rewrite -fE.
apply: (@measurable_fun_lim_sup _ h) => // t Dt.
- apply/bounded_fun_has_ubound/(@cvg_seq_bounded _ [normedModType R of R^o]).
  by apply/cvg_ex; eexists; exact: f_f.
- apply/bounded_fun_has_lbound/(@cvg_seq_bounded _ [normedModType R of R^o]).
  by apply/cvg_ex; eexists; exact: f_f.
Qed.

End measurable_fun_realType.

Section standard_emeasurable_fun.
Variable R : realType.

Lemma measurable_fun_EFin (D : set R) : measurable_fun D EFin.
Proof.
move=> mD; apply: (measurability (ErealGenOInfty.measurableE R)) => //.
move=> /= _ [_ [x ->]] <-; move: x => [x| |]; apply: measurableI => //.
- by rewrite preimage_itv_o_infty EFin_itv; exact: measurable_itv.
- by rewrite [X in measurable X](_ : _ = set0)// predeqE.
- by rewrite preimage_EFin_setT.
Qed.

Lemma measurable_fun_abse (D : set (\bar R)) : measurable_fun D abse.
Proof.
move=> mD; apply: (measurability (ErealGenOInfty.measurableE R)) => //.
move=> /= _ [_ [x ->] <-]; move: x => [x| |].
- rewrite [X in _ @^-1` X](punct_eitv_bnd_pinfty _ x) preimage_setU setIUr.
  apply: measurableU; last first.
    rewrite preimage_abse_pinfty.
    by apply: measurableI => //; apply: measurableU; exact: emeasurable_set1.
  apply: measurableI => //; exists (normr @^-1` `]x, +oo[%classic).
    rewrite -[X in measurable X]setTI.
    by apply: measurable_fun_normr => //; exact: measurable_itv.
  exists set0; first by constructor.
  rewrite setU0 predeqE => -[y| |]; split => /= => -[r];
    rewrite ?preimage_itv /= ?in_itv /= ?andbT => xr//.
    + by move=> [ry]; exists `|y| => //=; rewrite in_itv/= andbT -ry.
    + by move=> [ry]; exists y => //=; rewrite preimage_itv in_itv/= andbT -ry.
- by apply: measurableI => //; rewrite itv_opinfty_pinfty preimage_set0.
- apply: measurableI => //; rewrite itv_oninfty_pinfty -preimage_setC.
  by apply: measurableC; rewrite preimage_abse_ninfty.
Qed.

Lemma emeasurable_fun_minus (D : set (\bar R)) :
  measurable_fun D (-%E : \bar R -> \bar R).
Proof.
move=> mD; apply: (measurability (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite (_ : _ @^-1` _ = `]-oo, (- x)%E]%classic).
  by apply: measurableI => //; exact: emeasurable_itv_ninfty_bnd.
by rewrite predeqE => y; rewrite !preimage_itv !in_itv/= andbT in_itv lee_oppr.
Qed.

End standard_emeasurable_fun.
Hint Extern 0 (measurable_fun _ abse) =>
  solve [exact: measurable_fun_abse] : core.
Hint Extern 0 (measurable_fun _ EFin) =>
  solve [exact: measurable_fun_EFin] : core.

(* NB: real-valued function *)
Lemma EFin_measurable_fun (T : measurableType) (R : realType) (D : set T)
    (g : T -> R) :
  measurable_fun D (EFin \o g) <-> measurable_fun D g.
Proof.
split=> [mf mD A mA|]; last by move=> mg; exact: measurable_fun_comp.
rewrite [X in measurable X](_ : _ = D `&` (EFin \o g) @^-1` (EFin @` A)).
  by apply: mf => //; exists A => //; exists set0; [constructor|rewrite setU0].
congr (_ `&` _);rewrite eqEsubset; split=> [|? []/= _ /[swap] -[->//]].
by move=> ? ?; exact: preimage_image.
Qed.

Section emeasurable_fun.
Variables (T : measurableType) (R : realType).
Implicit Types (D : set T).

Lemma emeasurable_fun_ext D (f g : T -> \bar R) :
  {in D, f =1 g} -> measurable_fun D f -> measurable_fun D g.
Proof.
move=> fg mf mD A mA.
rewrite [X in measurable X](_ : _ = D `&` f @^-1` A); first exact: mf.
(* TODO: use lemma eq_preimage_in from lebesgue_integral.v *)
rewrite predeqE /preimage /= => x; split => [[Agx Dx]|[Afx Dx]].
  by split => //; rewrite fg// inE.
by split => //; rewrite -fg// inE.
Qed.

Lemma measurable_fun_ereal_inf D (f : (T -> \bar R)^nat) :
  (forall n, measurable_fun D (f n)) ->
  forall n, measurable_fun D (fun x => ereal_inf (sdrop (f ^~ x) n)).
Proof.
move=> mf n mD.
apply: (measurability (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite einfs_preimage -bigcapIr; last by exists n => /=.
by apply: bigcap_measurable => ? ?; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma measurable_fun_ereal_sup D (f : (T -> \bar R)^nat) :
  (forall n, measurable_fun D (f n)) ->
  forall n, measurable_fun D (fun x => ereal_sup (sdrop (f ^~ x) n)).
Proof.
move=> mf n mD; apply: (measurability (ErealGenOInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-];rewrite esups_preimage setI_bigcupr.
by apply: bigcup_measurable => ? ?; exact/mf/emeasurable_itv_bnd_pinfty.
Qed.

Lemma emeasurable_fun_max D (f g : T -> \bar R) :
  measurable_fun D f -> measurable_fun D g ->
  measurable_fun D (fun x => maxe (f x) (g x)).
Proof.
move=> mf mg mD; apply: (measurability (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite [X in measurable X](_ : _ =
    (D `&` f @^-1` `[x, +oo[) `|` (D `&` g @^-1` `[x, +oo[)); last first.
  rewrite predeqE => t /=; split.
    by rewrite !preimage_itv /= !in_itv /= !andbT le_maxr => -[Dx /orP[|]];
      tauto.
  by move=> [|]; rewrite !preimage_itv /= !in_itv/= !andbT le_maxr;
    move=> [Dx ->]//; rewrite orbT.
by apply: measurableU; [exact/mf/emeasurable_itv_bnd_pinfty|
                        exact/mg/emeasurable_itv_bnd_pinfty].
Qed.

Lemma emeasurable_fun_min D (f g : T -> \bar R) :
  measurable_fun D f -> measurable_fun D g ->
  measurable_fun D (fun x => mine (f x) (g x)).
Proof.
move=> mf mg mD; apply: (measurability (ErealGenCInfty.measurableE R)) => //.
move=> _ [_ [x ->] <-]; rewrite [X in measurable X](_ : _ =
    (D `&` f @^-1` `[x, +oo[) `&` (D `&` g @^-1` `[x, +oo[)); last first.
  rewrite predeqE => t /=; split.
    rewrite !preimage_itv !in_itv /= !andbT le_minr => -[Dt /andP[xft xgt]].
    tauto.
  move=> []; rewrite !preimage_itv !in_itv/= !andbT le_minr=> -[Dt xft [_ xgt]].
  by split => //; rewrite xft xgt.
by apply: measurableI; [exact/mf/emeasurable_itv_bnd_pinfty|
                        exact/mg/emeasurable_itv_bnd_pinfty].
Qed.

Lemma measurable_fun_elim_sup D (f : (T -> \bar R)^nat) :
  (forall n, measurable_fun D (f n)) ->
  measurable_fun D (fun x => elim_sup (f ^~ x)).
Proof.
move=> mf mD; rewrite (_ :  (fun _ => _) =
    (fun x => ereal_inf [set esups (f^~ x) n | n in [set n | n >= 0]%N])).
  by apply: measurable_fun_ereal_inf => // k; exact: measurable_fun_ereal_sup.
rewrite funeqE => t; apply/cvg_lim => //.
rewrite [X in _ --> X](_ : _ = ereal_inf [set of esups (f^~t)]).
  exact: cvg_esups_inf.
by congr (ereal_inf [set _ | _ in _]); rewrite predeqE.
Qed.

Lemma emeasurable_fun_cvg D (f_ : (T -> \bar R)^nat) (f : T -> \bar R) :
  (forall m, measurable_fun D (f_ m)) ->
  (forall x, D x -> f_ ^~ x --> f x) -> measurable_fun D f.
Proof.
move=> mf_ f_f; have fE x : D x -> f x = elim_sup (f_^~ x).
  by move=> Dx; have /cvg_lim  <-// := (@cvg_esups _ (f_^~x) (f x) (f_f x Dx)).
apply: (@emeasurable_fun_ext _ (fun x => elim_sup (f_ ^~ x))) => //.
  by move=> x; rewrite inE => Dx; rewrite fE.
exact: measurable_fun_elim_sup.
Qed.

End emeasurable_fun.

Definition preimage_classes (T1 T2 : measurableType) (T : Type)
    (f1 : T -> T1) (f2 : T -> T2)  :=
  s<< preimage_class setT f1 measurable `|`
      preimage_class setT f2 measurable >>.

Section product_lemma.
Variables (T1 T2 : measurableType) (T : pointedType) (f1 : T -> T1) (f2 : T -> T2).
Variables (T3 : Type) (g : T3 -> T).

Lemma preimage_classes_comp : preimage_classes (f1 \o g) (f2 \o g) =
                              preimage_class setT g (preimage_classes f1 f2).
Proof.
rewrite {1}/preimage_classes -transfer; congr (s<< _ >>).
rewrite predeqE => C; split.
- move=> [[A mA <-{C}]|[A mA <-{C}]].
  + by exists (f1 @^-1` A) => //; left; exists A => //; rewrite setTI.
  + by exists (f2 @^-1` A) => //; right; exists A => //; rewrite setTI.
- move=> [A [[B mB <-{A} <-{C}]|[B mB <-{A} <-{C}]]].
  + by left; rewrite !setTI; exists B => //; rewrite setTI.
  + by right; rewrite !setTI; exists B => //; rewrite setTI.
Qed.

End product_lemma.

Definition prod_measurable (T1 T2 : measurableType) := (T1 * T2)%type.

Section product_salgebra_instance.
Variables (T1 T2 : measurableType).
Let f1 := @fst T1 T2.
Let f2 := @snd T1 T2.

Lemma prod_salgebra_set0 : preimage_classes f1 f2 (set0 : set (T1 * T2)).
Proof. exact: g_salgebra_set0. Qed.

Lemma prod_salgebra_setC A : preimage_classes f1 f2 A ->
  preimage_classes f1 f2 (~` A).
Proof. exact: g_salgebra_on_setC_setT. Qed.

Lemma prod_salgebra_bigcup (F : _^nat) : (forall i, preimage_classes f1 f2 (F i)) ->
  preimage_classes f1 f2 (\bigcup_i (F i)).
Proof. exact: g_salgebra_bigcup. Qed.

HB.instance Definition prod_salgebra_mixin :=
  @isMeasurable.Build (T1 * T2)%type (Pointed.class _) (preimage_classes f1 f2)
    (prod_salgebra_set0) (prod_salgebra_setC) (prod_salgebra_bigcup).

Definition prod_measurableType := [the measurableType of prod_measurable T1 T2].

End product_salgebra_instance.

Lemma measurableM (T1 T2 : measurableType) (A : set T1) (B : set T2) :
  measurable A -> measurable B -> measurable (A `*` B).
Proof.
move=> mA mB.
have -> : A `*` B = (A `*` setT) `&` (setT `*` B) :> set (T1 * T2).
  by rewrite -{1}(setIT A) -{1}(setTI B) setMI.
rewrite setMT setTM; apply: measurableI.
- by apply: g_salgebra_self; left; exists A => //; rewrite setTI.
- by apply: g_salgebra_self; right; exists B => //; rewrite setTI.
Qed.

Section product_salgebra_measurableType.
Variables (T1 T2 : measurableType).
Let M1 := @measurable T1.
Let M2 := @measurable T2.
Let M1xM2 := [set A `*` B | A in M1 & B in M2].

Lemma measurable_prod_measurableType :
  @measurable (prod_measurableType T1 T2) = s<< M1xM2 >>.
Proof.
rewrite eqEsubset; split.
  apply: g_salgebra_smallest; last apply: are_measurable_sets_g_salgebra.
  rewrite subUset; split.
  - have /subset_trans : preimage_class setT fst M1 `<=` M1xM2.
      by move=> _ [X MX <-]; exists X=> //; exists setT; rewrite /M2 // setIC//.
    by apply; exact: g_salgebra_self.
  - have /subset_trans : preimage_class setT snd M2 `<=` M1xM2.
      by move=> _ [Y MY <-]; exists setT; rewrite /M1 //; exists Y.
    by apply; exact: g_salgebra_self.
apply: g_salgebra_smallest; last exact: are_measurable_sets_g_salgebra.
by move=> _ [A MA] [B MB] <-; apply: measurableM => //; exact: g_salgebra_self.
Qed.

End product_salgebra_measurableType.

Section product_salgebra_g_measurableTypeR.
Variables (T1 : measurableType) (T2 : pointedType) (C2 : set (set T2)).
Hypothesis (setTC2 : setT `<=` C2).

(* NB: useful? *)
Lemma measurable_prod_g_measurableTypeR :
  @measurable (prod_measurableType T1 (g_measurableType C2))
  = s<< [set A `*` B | A in measurable & B in C2] >>.
Proof.
rewrite measurable_prod_measurableType //; congr (s<< _ >>).
rewrite predeqE => X; split=> [[A mA] [B mB] <-{X}|[A C1A] [B C2B] <-{X}].
  by exists A => //; exists B => //; exact: setTC2.
by exists A => //; exists B => //; exact: g_salgebra_self.
Qed.

End product_salgebra_g_measurableTypeR.

Section product_salgebra_g_measurableType.
Variables (T1 T2 : pointedType) (C1 : set (set T1)) (C2 : set (set T2)).
Hypotheses (setTC1 : setT `<=` C1) (setTC2 : setT `<=` C2).

Lemma measurable_prod_g_measurableType :
  @measurable (prod_measurableType (g_measurableType C1) (g_measurableType C2))
  = s<< [set A `*` B | A in C1 & B in C2] >>.
Proof.
rewrite measurable_prod_measurableType //; congr (s<< _ >>).
rewrite predeqE => X; split=> [[A mA] [B mB] <-{X}|[A C1A] [B C2B] <-{X}].
  by exists A; [exact: setTC1|exists B => //; exact: setTC2].
by exists A; [exact: g_salgebra_self|exists B => //; exact: g_salgebra_self].
Qed.

End product_salgebra_g_measurableType.

Section prod_measurable_fun.
Variables (T T1 T2 : measurableType) (f : T -> prod_measurableType T1 T2).

Lemma prod_measurable_funP : measurable_fun setT f <->
  measurable_fun setT (fst \o f) /\ measurable_fun setT (snd \o f).
Proof.
apply: (@iff_trans _ (preimage_classes (fst \o f) (snd \o f) `<=` measurable)).
- rewrite preimage_classes_comp; split=> [mf A [C HC <-]|f12]; first exact: mf.
  by move=> _ A mA; apply: f12; exists A.
- split => [h|[mf1 mf2]].
    by split => _ A mA; apply/h/g_salgebra_self; [left; exists A|right; exists A].
  apply: g_salgebra_smallest; last exact: are_measurable_sets_measurable.
  by rewrite subUset; split=> [|] A [C mC <-]; [exact: mf1|exact: mf2].
Qed.

End prod_measurable_fun.

Section partial_measurable_fun.
Variables (T T1 T2 : measurableType) (f : prod_measurableType T1 T2 -> T).

Lemma measurable_fun_prod1 x :
  measurable_fun setT f -> measurable_fun setT (fun y => f (x, y)).
Proof.
move=> mf; pose pairx := fun y : T2 => (x, y).
have m1pairx : measurable_fun setT (fst \o pairx) by exact/measurable_fun_cst.
have m2pairx : measurable_fun setT (snd \o pairx) by exact/measurable_fun_id.
have : measurable_fun setT pairx by exact/(proj2 (prod_measurable_funP _)).
exact: measurable_fun_comp.
Qed.

Lemma measurable_fun_prod2 y :
  measurable_fun setT f -> measurable_fun setT (fun x => f (x, y)).
Proof.
move=> mf; pose pairy := fun x : T1 => (x, y).
have m1pairy : measurable_fun setT (fst \o pairy) by exact/measurable_fun_id.
have m2pairy : measurable_fun setT (snd \o pairy) by exact/measurable_fun_cst.
have : measurable_fun setT pairy by exact/(proj2 (prod_measurable_funP _)).
exact: measurable_fun_comp.
Qed.

End partial_measurable_fun.
